[
    {
        "label": "pytest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pytest",
        "description": "pytest",
        "detail": "pytest",
        "documentation": {}
    },
    {
        "label": "array_manipulation",
        "importPath": "array_manipulation",
        "description": "array_manipulation",
        "isExtraImport": true,
        "detail": "array_manipulation",
        "documentation": {}
    },
    {
        "label": "minimum_swaps",
        "importPath": "minimum_swaps_2",
        "description": "minimum_swaps_2",
        "isExtraImport": true,
        "detail": "minimum_swaps_2",
        "documentation": {}
    },
    {
        "label": "new_year_chaos",
        "importPath": "new_year_chaos",
        "description": "new_year_chaos",
        "isExtraImport": true,
        "detail": "new_year_chaos",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "TypeVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "ceil",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "factorial",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "factorial",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "floor",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "ceil",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "floor",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "randrange",
        "importPath": "random",
        "description": "random",
        "isExtraImport": true,
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "randrange",
        "importPath": "random",
        "description": "random",
        "isExtraImport": true,
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "count_triplets",
        "importPath": "count_triplets",
        "description": "count_triplets",
        "isExtraImport": true,
        "detail": "count_triplets",
        "documentation": {}
    },
    {
        "label": "parse_list",
        "importPath": "utils.parser",
        "description": "utils.parser",
        "isExtraImport": true,
        "detail": "utils.parser",
        "documentation": {}
    },
    {
        "label": "sherlock_and_anagrams",
        "importPath": "sherlock_and_anagrams",
        "description": "sherlock_and_anagrams",
        "isExtraImport": true,
        "detail": "sherlock_and_anagrams",
        "documentation": {}
    },
    {
        "label": "hourglass_sum",
        "importPath": "hourglass_sum",
        "description": "hourglass_sum",
        "isExtraImport": true,
        "detail": "hourglass_sum",
        "documentation": {}
    },
    {
        "label": "unittest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "unittest",
        "description": "unittest",
        "detail": "unittest",
        "documentation": {}
    },
    {
        "label": "TestCase",
        "importPath": "unittest",
        "description": "unittest",
        "isExtraImport": true,
        "detail": "unittest",
        "documentation": {}
    },
    {
        "label": "TestCase",
        "importPath": "unittest",
        "description": "unittest",
        "isExtraImport": true,
        "detail": "unittest",
        "documentation": {}
    },
    {
        "label": "TestCase",
        "importPath": "unittest",
        "description": "unittest",
        "isExtraImport": true,
        "detail": "unittest",
        "documentation": {}
    },
    {
        "label": "TestCase",
        "importPath": "unittest",
        "description": "unittest",
        "isExtraImport": true,
        "detail": "unittest",
        "documentation": {}
    },
    {
        "label": "bracket_combinations",
        "importPath": "challenges.math.bracket_combinations",
        "description": "challenges.math.bracket_combinations",
        "isExtraImport": true,
        "detail": "challenges.math.bracket_combinations",
        "documentation": {}
    },
    {
        "label": "MinWindowSubstring",
        "importPath": "challenges.strings.min_window_substring",
        "description": "challenges.strings.min_window_substring",
        "isExtraImport": true,
        "detail": "challenges.strings.min_window_substring",
        "documentation": {}
    },
    {
        "label": "QuestionMarks",
        "importPath": "challenges.strings.question_marks",
        "description": "challenges.strings.question_marks",
        "isExtraImport": true,
        "detail": "challenges.strings.question_marks",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "tree_constructor",
        "importPath": "challenges.trees.tree_constructor",
        "description": "challenges.trees.tree_constructor",
        "isExtraImport": true,
        "detail": "challenges.trees.tree_constructor",
        "documentation": {}
    },
    {
        "label": "ABC",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABCMeta",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "ABCMeta",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "abstractmethod",
        "importPath": "abc",
        "description": "abc",
        "isExtraImport": true,
        "detail": "abc",
        "documentation": {}
    },
    {
        "label": "Node",
        "importPath": "node",
        "description": "node",
        "isExtraImport": true,
        "detail": "node",
        "documentation": {}
    },
    {
        "label": "Node",
        "importPath": "node",
        "description": "node",
        "isExtraImport": true,
        "detail": "node",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "SinglyLinkedList",
        "importPath": "linked_list",
        "description": "linked_list",
        "isExtraImport": true,
        "detail": "linked_list",
        "documentation": {}
    },
    {
        "label": "binary_search_recursive",
        "importPath": "divide_and_conquer_pattern",
        "description": "divide_and_conquer_pattern",
        "isExtraImport": true,
        "detail": "divide_and_conquer_pattern",
        "documentation": {}
    },
    {
        "label": "binary_search_iterative",
        "importPath": "divide_and_conquer_pattern",
        "description": "divide_and_conquer_pattern",
        "isExtraImport": true,
        "detail": "divide_and_conquer_pattern",
        "documentation": {}
    },
    {
        "label": "same",
        "importPath": "frequency_counter_pattern",
        "description": "frequency_counter_pattern",
        "isExtraImport": true,
        "detail": "frequency_counter_pattern",
        "documentation": {}
    },
    {
        "label": "same_naive",
        "importPath": "frequency_counter_pattern",
        "description": "frequency_counter_pattern",
        "isExtraImport": true,
        "detail": "frequency_counter_pattern",
        "documentation": {}
    },
    {
        "label": "is_anagram",
        "importPath": "frequency_counter_pattern",
        "description": "frequency_counter_pattern",
        "isExtraImport": true,
        "detail": "frequency_counter_pattern",
        "documentation": {}
    },
    {
        "label": "same_frequency",
        "importPath": "frequency_counter_pattern",
        "description": "frequency_counter_pattern",
        "isExtraImport": true,
        "detail": "frequency_counter_pattern",
        "documentation": {}
    },
    {
        "label": "are_there_duplicates",
        "importPath": "frequency_counter_pattern",
        "description": "frequency_counter_pattern",
        "isExtraImport": true,
        "detail": "frequency_counter_pattern",
        "documentation": {}
    },
    {
        "label": "time_func",
        "importPath": "utils.time",
        "description": "utils.time",
        "isExtraImport": true,
        "detail": "utils.time",
        "documentation": {}
    },
    {
        "label": "time_func",
        "importPath": "utils.time",
        "description": "utils.time",
        "isExtraImport": true,
        "detail": "utils.time",
        "documentation": {}
    },
    {
        "label": "sum_zero",
        "importPath": "multiple_pointers_pattern",
        "description": "multiple_pointers_pattern",
        "isExtraImport": true,
        "detail": "multiple_pointers_pattern",
        "documentation": {}
    },
    {
        "label": "count_unique_values",
        "importPath": "multiple_pointers_pattern",
        "description": "multiple_pointers_pattern",
        "isExtraImport": true,
        "detail": "multiple_pointers_pattern",
        "documentation": {}
    },
    {
        "label": "are_there_duplicates",
        "importPath": "multiple_pointers_pattern",
        "description": "multiple_pointers_pattern",
        "isExtraImport": true,
        "detail": "multiple_pointers_pattern",
        "documentation": {}
    },
    {
        "label": "average_pair",
        "importPath": "multiple_pointers_pattern",
        "description": "multiple_pointers_pattern",
        "isExtraImport": true,
        "detail": "multiple_pointers_pattern",
        "documentation": {}
    },
    {
        "label": "is_subsequence",
        "importPath": "multiple_pointers_pattern",
        "description": "multiple_pointers_pattern",
        "isExtraImport": true,
        "detail": "multiple_pointers_pattern",
        "documentation": {}
    },
    {
        "label": "max_subarray_sum",
        "importPath": "sliding_window_pattern",
        "description": "sliding_window_pattern",
        "isExtraImport": true,
        "detail": "sliding_window_pattern",
        "documentation": {}
    },
    {
        "label": "min_subarray_len",
        "importPath": "sliding_window_pattern",
        "description": "sliding_window_pattern",
        "isExtraImport": true,
        "detail": "sliding_window_pattern",
        "documentation": {}
    },
    {
        "label": "find_longest_substring",
        "importPath": "sliding_window_pattern",
        "description": "sliding_window_pattern",
        "isExtraImport": true,
        "detail": "sliding_window_pattern",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "collect_odd_values",
        "importPath": "recursion",
        "description": "recursion",
        "isExtraImport": true,
        "detail": "recursion",
        "documentation": {}
    },
    {
        "label": "collect_odd_values_pure",
        "importPath": "recursion",
        "description": "recursion",
        "isExtraImport": true,
        "detail": "recursion",
        "documentation": {}
    },
    {
        "label": "power",
        "importPath": "recursion",
        "description": "recursion",
        "isExtraImport": true,
        "detail": "recursion",
        "documentation": {}
    },
    {
        "label": "factorial",
        "importPath": "recursion",
        "description": "recursion",
        "isExtraImport": true,
        "detail": "recursion",
        "documentation": {}
    },
    {
        "label": "product_of_array",
        "importPath": "recursion",
        "description": "recursion",
        "isExtraImport": true,
        "detail": "recursion",
        "documentation": {}
    },
    {
        "label": "sum_range",
        "importPath": "recursion",
        "description": "recursion",
        "isExtraImport": true,
        "detail": "recursion",
        "documentation": {}
    },
    {
        "label": "fib",
        "importPath": "recursion",
        "description": "recursion",
        "isExtraImport": true,
        "detail": "recursion",
        "documentation": {}
    },
    {
        "label": "reverse",
        "importPath": "recursion",
        "description": "recursion",
        "isExtraImport": true,
        "detail": "recursion",
        "documentation": {}
    },
    {
        "label": "is_palindrome",
        "importPath": "recursion",
        "description": "recursion",
        "isExtraImport": true,
        "detail": "recursion",
        "documentation": {}
    },
    {
        "label": "some_recursive",
        "importPath": "recursion",
        "description": "recursion",
        "isExtraImport": true,
        "detail": "recursion",
        "documentation": {}
    },
    {
        "label": "flatten_pure",
        "importPath": "recursion",
        "description": "recursion",
        "isExtraImport": true,
        "detail": "recursion",
        "documentation": {}
    },
    {
        "label": "flatten_helper",
        "importPath": "recursion",
        "description": "recursion",
        "isExtraImport": true,
        "detail": "recursion",
        "documentation": {}
    },
    {
        "label": "capitalize_first",
        "importPath": "recursion",
        "description": "recursion",
        "isExtraImport": true,
        "detail": "recursion",
        "documentation": {}
    },
    {
        "label": "nested_even_sum",
        "importPath": "recursion",
        "description": "recursion",
        "isExtraImport": true,
        "detail": "recursion",
        "documentation": {}
    },
    {
        "label": "capitalize_words",
        "importPath": "recursion",
        "description": "recursion",
        "isExtraImport": true,
        "detail": "recursion",
        "documentation": {}
    },
    {
        "label": "stringify_numbers",
        "importPath": "recursion",
        "description": "recursion",
        "isExtraImport": true,
        "detail": "recursion",
        "documentation": {}
    },
    {
        "label": "collect_strings",
        "importPath": "recursion",
        "description": "recursion",
        "isExtraImport": true,
        "detail": "recursion",
        "documentation": {}
    },
    {
        "label": "linear_search",
        "importPath": "searching_algorithms",
        "description": "searching_algorithms",
        "isExtraImport": true,
        "detail": "searching_algorithms",
        "documentation": {}
    },
    {
        "label": "binary_search",
        "importPath": "searching_algorithms",
        "description": "searching_algorithms",
        "isExtraImport": true,
        "detail": "searching_algorithms",
        "documentation": {}
    },
    {
        "label": "naive_string_search",
        "importPath": "searching_algorithms",
        "description": "searching_algorithms",
        "isExtraImport": true,
        "detail": "searching_algorithms",
        "documentation": {}
    },
    {
        "label": "bubble_sort",
        "importPath": "sorting_algorithms",
        "description": "sorting_algorithms",
        "isExtraImport": true,
        "detail": "sorting_algorithms",
        "documentation": {}
    },
    {
        "label": "selection_sort",
        "importPath": "sorting_algorithms",
        "description": "sorting_algorithms",
        "isExtraImport": true,
        "detail": "sorting_algorithms",
        "documentation": {}
    },
    {
        "label": "insertion_sort",
        "importPath": "sorting_algorithms",
        "description": "sorting_algorithms",
        "isExtraImport": true,
        "detail": "sorting_algorithms",
        "documentation": {}
    },
    {
        "label": "compare_and_sort",
        "importPath": "sorting_algorithms",
        "description": "sorting_algorithms",
        "isExtraImport": true,
        "detail": "sorting_algorithms",
        "documentation": {}
    },
    {
        "label": "merge_sort",
        "importPath": "sorting_algorithms",
        "description": "sorting_algorithms",
        "isExtraImport": true,
        "detail": "sorting_algorithms",
        "documentation": {}
    },
    {
        "label": "pivot",
        "importPath": "sorting_algorithms",
        "description": "sorting_algorithms",
        "isExtraImport": true,
        "detail": "sorting_algorithms",
        "documentation": {}
    },
    {
        "label": "quick_sort",
        "importPath": "sorting_algorithms",
        "description": "sorting_algorithms",
        "isExtraImport": true,
        "detail": "sorting_algorithms",
        "documentation": {}
    },
    {
        "label": "radix_sort",
        "importPath": "sorting_algorithms",
        "description": "sorting_algorithms",
        "isExtraImport": true,
        "detail": "sorting_algorithms",
        "documentation": {}
    },
    {
        "label": "flatten",
        "importPath": "sorting_algorithms",
        "description": "sorting_algorithms",
        "isExtraImport": true,
        "detail": "sorting_algorithms",
        "documentation": {}
    },
    {
        "label": "get_num_digits",
        "importPath": "sorting_algorithms",
        "description": "sorting_algorithms",
        "isExtraImport": true,
        "detail": "sorting_algorithms",
        "documentation": {}
    },
    {
        "label": "get_max_digits",
        "importPath": "sorting_algorithms",
        "description": "sorting_algorithms",
        "isExtraImport": true,
        "detail": "sorting_algorithms",
        "documentation": {}
    },
    {
        "label": "get_ith_digit",
        "importPath": "sorting_algorithms",
        "description": "sorting_algorithms",
        "isExtraImport": true,
        "detail": "sorting_algorithms",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "array_manipulation_brute_force",
        "kind": 2,
        "importPath": "challenges.array.array_manipulation.array_manipulation",
        "description": "challenges.array.array_manipulation.array_manipulation",
        "peekOfCode": "def array_manipulation_brute_force(n, queries):\n    \"\"\"\n    exceeds memory limit\n    \"\"\"\n    arr = [0] * n\n    for start, end, add in queries:\n        arr[start - 1 : end] = map(lambda x: x + add, arr[start - 1 : end])\n    return max(arr)\ndef array_manipulation_hashmap(n, queries):\n    \"\"\"",
        "detail": "challenges.array.array_manipulation.array_manipulation",
        "documentation": {}
    },
    {
        "label": "array_manipulation_hashmap",
        "kind": 2,
        "importPath": "challenges.array.array_manipulation.array_manipulation",
        "description": "challenges.array.array_manipulation.array_manipulation",
        "peekOfCode": "def array_manipulation_hashmap(n, queries):\n    \"\"\"\n    too slow\n    \"\"\"\n    indexes = {}\n    mx = 0\n    for a, b, k in queries:\n        for i in range(a, b + 1):\n            if i in indexes:\n                indexes[i] += k",
        "detail": "challenges.array.array_manipulation.array_manipulation",
        "documentation": {}
    },
    {
        "label": "array_manipulation_optimized",
        "kind": 2,
        "importPath": "challenges.array.array_manipulation.array_manipulation",
        "description": "challenges.array.array_manipulation.array_manipulation",
        "peekOfCode": "def array_manipulation_optimized(n, queries):\n    \"\"\"\n    if current range overlaps with prev range\n    > take max from overlapping part\n    if not:\n        if k <= current max, skip\n        if k > current max, reset max\n    keep max at each layer\n    -> no. if next layer adds 1M to a random position, we need\n    to know the existing value at that position.",
        "detail": "challenges.array.array_manipulation.array_manipulation",
        "documentation": {}
    },
    {
        "label": "array_manipulation_prefix_sum",
        "kind": 2,
        "importPath": "challenges.array.array_manipulation.array_manipulation",
        "description": "challenges.array.array_manipulation.array_manipulation",
        "peekOfCode": "def array_manipulation_prefix_sum(n, queries):\n    \"\"\"\n    2023-02-13 07:36:54\n    Did not pass the time limit\n    \"\"\"\n    arr = [0] * n\n    for a, b, k in queries:\n        arr[a - 1] += k\n        if b < n:\n            arr[b] -= k",
        "detail": "challenges.array.array_manipulation.array_manipulation",
        "documentation": {}
    },
    {
        "label": "array_manipulation_prefix_sum_optimized",
        "kind": 2,
        "importPath": "challenges.array.array_manipulation.array_manipulation",
        "description": "challenges.array.array_manipulation.array_manipulation",
        "peekOfCode": "def array_manipulation_prefix_sum_optimized(n, queries):\n    \"\"\"\n    2023-02-13 07:40:52\n    \"\"\"\n    arr = [0] * n\n    for a, b, k in queries:\n        arr[a - 1] += k\n        if b < n:\n            arr[b] -= k\n    mx = 0",
        "detail": "challenges.array.array_manipulation.array_manipulation",
        "documentation": {}
    },
    {
        "label": "array_manipulation",
        "kind": 5,
        "importPath": "challenges.array.array_manipulation.array_manipulation",
        "description": "challenges.array.array_manipulation.array_manipulation",
        "peekOfCode": "array_manipulation = array_manipulation_prefix_sum_optimized",
        "detail": "challenges.array.array_manipulation.array_manipulation",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 2,
        "importPath": "challenges.array.array_manipulation.array_manipulation_tests",
        "description": "challenges.array.array_manipulation.array_manipulation_tests",
        "peekOfCode": "def test(test_input, expected):\n    assert array_manipulation(*test_input) == expected\n\"\"\"\n10 [10, 10, 0,  0,  0, 0, 0, 0, 0, 0]\n 9 [10, 19, 9,  0,  0, 0, 0, 0, 0, 0]\n11 [10, 19, 20, 11, 0, 0, 0, 0, 0, 0]\n\"\"\"",
        "detail": "challenges.array.array_manipulation.array_manipulation_tests",
        "documentation": {}
    },
    {
        "label": "minimumSwaps_send_to_correct_position",
        "kind": 2,
        "importPath": "challenges.array.minimum_swaps_2.minimum_swaps_2",
        "description": "challenges.array.minimum_swaps_2.minimum_swaps_2",
        "peekOfCode": "def minimumSwaps_send_to_correct_position(arr):\n    \"\"\"\n    2023-02-04 11:57:53\n    Uses the assumption that the given array contains sequential integers starting at 1.\n    Final sorted array should be [1, 2, 3, ..., n]\n    We can infer the correct position of the item by its value.\n    - if 3 is at index 0, it should eventually go to index position 2\n    - repeat sending the value at the correct position until the current value\n      matches the current index + 1.\n    Using selection sort is the wrong approach and takes quadratic time",
        "detail": "challenges.array.minimum_swaps_2.minimum_swaps_2",
        "documentation": {}
    },
    {
        "label": "minimumSwaps",
        "kind": 2,
        "importPath": "challenges.array.minimum_swaps_2.minimum_swaps_2",
        "description": "challenges.array.minimum_swaps_2.minimum_swaps_2",
        "peekOfCode": "def minimumSwaps(arr):\n    count = 0\n    i = 0\n    while i < len(arr) - 1:\n        o_idx = arr[i] - 1\n        if o_idx == i:\n            i += 1\n        else:\n            arr[i], arr[o_idx] = arr[o_idx], arr[i]\n            count += 1",
        "detail": "challenges.array.minimum_swaps_2.minimum_swaps_2",
        "documentation": {}
    },
    {
        "label": "minimumSwaps_fails_using_dynamic_indexing",
        "kind": 2,
        "importPath": "challenges.array.minimum_swaps_2.minimum_swaps_2",
        "description": "challenges.array.minimum_swaps_2.minimum_swaps_2",
        "peekOfCode": "def minimumSwaps_fails_using_dynamic_indexing(arr):\n    \"\"\"\n    2023-03-01 08:01:58\n    This one results in a infinite loop because it's getting index position from the newly swapped value.\n    Pythonic swap with tuple only works if you save the swapping index into a variable.\n    [output]\n    # starting values\n    i: 0, arr: [4, 3, 1, 2], count: 0\n    # arr[arr[i] - 1 -> 3](2) is copied to index 0, but arr[i](4) is copied to the new arr[i] - 1(1).\n    i: 0, arr: [2, 4, 1, 2], count: 0",
        "detail": "challenges.array.minimum_swaps_2.minimum_swaps_2",
        "documentation": {}
    },
    {
        "label": "minimum_swaps",
        "kind": 5,
        "importPath": "challenges.array.minimum_swaps_2.minimum_swaps_2",
        "description": "challenges.array.minimum_swaps_2.minimum_swaps_2",
        "peekOfCode": "minimum_swaps = minimumSwaps_send_to_correct_position",
        "detail": "challenges.array.minimum_swaps_2.minimum_swaps_2",
        "documentation": {}
    },
    {
        "label": "test__success",
        "kind": 2,
        "importPath": "challenges.array.minimum_swaps_2.minimum_swaps_2_tests",
        "description": "challenges.array.minimum_swaps_2.minimum_swaps_2_tests",
        "peekOfCode": "def test__success(test_input, expected):\n    assert minimum_swaps(test_input) == expected",
        "detail": "challenges.array.minimum_swaps_2.minimum_swaps_2_tests",
        "documentation": {}
    },
    {
        "label": "minimumBribes_logic_too_complex",
        "kind": 2,
        "importPath": "challenges.array.new_year_chaos.new_year_chaos",
        "description": "challenges.array.new_year_chaos.new_year_chaos",
        "peekOfCode": "def minimumBribes_logic_too_complex(q):\n    \"\"\"\n    Tried to keep O(n) by breaking down to cases,\n    but in general, stay away from many if statements for\n    algorithm questions.\n    [3, 2, 1, 4]\n    0 3: (3-1) - 0 = 2 -> 2 bribes\n    1 2: (2-1) - 1 = 0, but still bribed 1. if latest_bribed > curr then\n         original_index = (n - 1) - i + bribes\n         -> we cannot use this because we don't know how many of the bribes",
        "detail": "challenges.array.new_year_chaos.new_year_chaos",
        "documentation": {}
    },
    {
        "label": "min_bribes_look_behind",
        "kind": 2,
        "importPath": "challenges.array.new_year_chaos.new_year_chaos",
        "description": "challenges.array.new_year_chaos.new_year_chaos",
        "peekOfCode": "def min_bribes_look_behind(q):\n    \"\"\"\n    2023-02-11 14:15:42\n    original index can still be same as current index\n    after getting paid when a person behind you bribes you and\n    person ahead of you, then you bribe the person ahead of you\n    to get back to the original position.\n    \"\"\"\n    bribes = 0\n    for i, v in enumerate(q):",
        "detail": "challenges.array.new_year_chaos.new_year_chaos",
        "documentation": {}
    },
    {
        "label": "minimumBribes_use_value",
        "kind": 2,
        "importPath": "challenges.array.new_year_chaos.new_year_chaos",
        "description": "challenges.array.new_year_chaos.new_year_chaos",
        "peekOfCode": "def minimumBribes_use_value(q):\n    \"\"\"\n    2023-02-21 08:29:31\n    1, 2, 5, 4, 3\n    - 5 bribed 3 & 4\n    - 4 bribed 3\n    can't get total bribes by current position alone because\n    someone behind you can bribe you and the person before you\n    and you can come back to the original position by bribing\n    the person in front of you.",
        "detail": "challenges.array.new_year_chaos.new_year_chaos",
        "documentation": {}
    },
    {
        "label": "new_year_chaos",
        "kind": 5,
        "importPath": "challenges.array.new_year_chaos.new_year_chaos",
        "description": "challenges.array.new_year_chaos.new_year_chaos",
        "peekOfCode": "new_year_chaos = minimumBribes_use_value",
        "detail": "challenges.array.new_year_chaos.new_year_chaos",
        "documentation": {}
    },
    {
        "label": "test__either_bribe_or_get_bribed",
        "kind": 2,
        "importPath": "challenges.array.new_year_chaos.new_year_chaos_tests",
        "description": "challenges.array.new_year_chaos.new_year_chaos_tests",
        "peekOfCode": "def test__either_bribe_or_get_bribed(\n    capsys: pytest.CaptureFixture, test_input, expected\n):\n    new_year_chaos(test_input)\n    captured = capsys.readouterr()\n    assert captured.out.strip() == str(expected)\n@pytest.mark.parametrize(\n    \"test_input, expected\",\n    [\n        ([1, 2, 5, 3, 7, 8, 6, 4], 7),",
        "detail": "challenges.array.new_year_chaos.new_year_chaos_tests",
        "documentation": {}
    },
    {
        "label": "test__get_bribed_and_bribe",
        "kind": 2,
        "importPath": "challenges.array.new_year_chaos.new_year_chaos_tests",
        "description": "challenges.array.new_year_chaos.new_year_chaos_tests",
        "peekOfCode": "def test__get_bribed_and_bribe(capsys: pytest.CaptureFixture, test_input, expected):\n    new_year_chaos(test_input)\n    captured = capsys.readouterr()\n    assert captured.out.strip() == str(expected)",
        "detail": "challenges.array.new_year_chaos.new_year_chaos_tests",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "challenges.array.best_time_to_buy_and_sell_stock_ii",
        "description": "challenges.array.best_time_to_buy_and_sell_stock_ii",
        "peekOfCode": "class Solution:\n    def maxProfit_look_back(self, prices: List[int]) -> int:\n        \"\"\"\n        Runtime: 86 ms (58%)\n        Memory Usage: 15 MB (98%)\n        starting from index 1 and looking back is a good way to avoid index out of range exception\n        when you're comparing neighboring values in the same array.\n        Exploit the requirement:\n        - Because we can sell and buy again immediately, we can keep selling as long as today's price is higher than yesterday's,\n        and immediately buy again at the today's price.",
        "detail": "challenges.array.best_time_to_buy_and_sell_stock_ii",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "challenges.array.contains_duplicate",
        "description": "challenges.array.contains_duplicate",
        "peekOfCode": "class Solution:\n    def containsDuplicate_set(self, nums: List[int]) -> bool:\n        \"\"\"\n        Runtime: 469 ms (93%)\n        Memory Usage: 25.9 MB (72%)\n        return early if you can by checking inside the loop\n        \"\"\"\n        s = set()\n        i = 0\n        for n in nums:",
        "detail": "challenges.array.contains_duplicate",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "challenges.array.intersection_of_two_arrays_2",
        "description": "challenges.array.intersection_of_two_arrays_2",
        "peekOfCode": "class Solution:\n    def intersect_counter(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        \"\"\"\n        2022-06-15T12:56:03.460Z\n        Runtime: 46 ms\n        Memory Usage: 13.9 MB\n        Constraints allow us to create hashmap ( <= 1000) to avoid O(n^2) loops\n        Use collections.Counter and binary operator (&) to get the intersection of to counters\n        Counter & Counter -> intersection\n        Counter | Counter -> Union",
        "detail": "challenges.array.intersection_of_two_arrays_2",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "challenges.array.move_zeroes",
        "description": "challenges.array.move_zeroes",
        "peekOfCode": "class Solution:\n    def moveZeroes_slicing_inside_loop(self, nums: List[int]) -> None:\n        \"\"\"\n        2022-06-17T12:28:51.268Z\n        Runtime: 1444 ms (7%) -> truncating decimals because leetcode distribution is flaky so the accuracy is not that meaningful\n        Memory Usage: 15.6 MB (64%)\n        Using list slicing, but slow because it's O(n^2)\n        \"\"\"\n        j = 0\n        for _ in range(len(nums)):",
        "detail": "challenges.array.move_zeroes",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "challenges.array.plus_one",
        "description": "challenges.array.plus_one",
        "peekOfCode": "class Solution:\n    def plusOne_convert_to_int(self, digits: List[int]) -> List[int]:\n        \"\"\"\n        2022-06-16T11:13:36.645Z\n        Runtime: 37 ms (80.25%)\n        Memory Usage: 13.8 MB (96.46%)\n        \"\"\"\n        s = \"\".join(map(str, digits))\n        n = int(s)\n        s = str(n + 1)",
        "detail": "challenges.array.plus_one",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "challenges.array.remove_duplicates_from_sorted_array",
        "description": "challenges.array.remove_duplicates_from_sorted_array",
        "peekOfCode": "class Solution:\n    def removeDuplicates_first_try(self, nums: List[int]) -> int:\n        \"\"\"\n        Runtime: 106 ms (75%)\n        Memory Usage: 15.6 MB (60%)\n        \"\"\"\n        if len(nums) <= 0:\n            return 0\n        curr_insert_at = 1\n        for i in range(1, len(nums)):",
        "detail": "challenges.array.remove_duplicates_from_sorted_array",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "challenges.array.rotate_array",
        "description": "challenges.array.rotate_array",
        "peekOfCode": "class Solution:\n    def rotate_by_slicing(self, nums: List[int], k: int) -> None:\n        \"\"\"\n        Runtime: 325 ms (54%)\n        Memory Usage: 25.4 MB (75%)\n        \"\"\"\n        k %= len(nums)\n        if k != 0:\n            nums[:] = nums[-k:] + nums[:-k]\n    def rotate_by_reverse_and_partial_reverse(self, nums: List[int], k: int) -> None:",
        "detail": "challenges.array.rotate_array",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "challenges.array.rotate_image",
        "description": "challenges.array.rotate_image",
        "peekOfCode": "class Solution:\n    def rotate_diagonal_swap_and_reverse(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        2022-06-20T11:17:27.787Z\n        Runtime: 39 ms (85%)\n        Memory Usage: 13.9 MB (74%)\n        col -> row\n        30 -> 00, 20 -> 01, 10 -> 01, 00 -> 03\n        inplace -> swap?\n        1 2 3 4",
        "detail": "challenges.array.rotate_image",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "challenges.array.single_number",
        "description": "challenges.array.single_number",
        "peekOfCode": "class Solution:\n    def singleNumber_inplace_reduction(self, nums: List[int]) -> int:\n        \"\"\"\n        2022-06-14T12:42:37.741Z\n        Runtime: 1342 ms (p15.01)\n        Memory Usage: 15.8 MB (p99.78)\n        remove inside for loop might still lead to O(n^2), but nums get smaller in each loop\n        so amortized time seems to be better than expected\n        \"\"\"\n        for i in range(len(nums), 0, -1):",
        "detail": "challenges.array.single_number",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "challenges.array.two_sum",
        "description": "challenges.array.two_sum",
        "peekOfCode": "class Solution:\n    def twoSum_bad_but_works(self, nums: List[int], target: int) -> List[int]:\n        \"\"\"\n        2022-06-19T15:24:08.426Z\n        Runtime: 8938 ms (0%)\n        Memory Usage: 17.3 MB (0%)\n        This one barely passes the time limit 🥲\n        Still O(n^2) but inner loop becomes smaller and smaller\n        2022-08-17 08:40:48\n        Why did I map the array and sorted? this is unnecessary! 😰",
        "detail": "challenges.array.two_sum",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "challenges.array.valid_sudoku",
        "description": "challenges.array.valid_sudoku",
        "peekOfCode": "class Solution:\n    def isValidSudoku_create_lists_first(self, board: List[List[str]]) -> bool:\n        \"\"\"\n        2022-06-19T22:11:55.519Z\n        Runtime: 99 ms\n        emory Usage: 13.9 MB\n        In order to figure out how to use i and j to create the lists of subgrids,\n        it was helpful to write out examples like this to see and get the intuition.\n        [00 01 02 10 11 12 20 21 22]\n        [03 04 05 13 14 15 23 24 25]",
        "detail": "challenges.array.valid_sudoku",
        "documentation": {}
    },
    {
        "label": "is_valid",
        "kind": 2,
        "importPath": "challenges.array.valid_sudoku",
        "description": "challenges.array.valid_sudoku",
        "peekOfCode": "def is_valid(nums: List[str]):\n    s = set(range(1, 10))\n    for n in [int(x) for x in nums if x != \".\"]:\n        if n in s:\n            s.remove(n)\n        else:\n            return False\n    return True\ndef get_subgrid(board, i, j):\n    # We could do this manually one by one since there are only 3 rows.",
        "detail": "challenges.array.valid_sudoku",
        "documentation": {}
    },
    {
        "label": "get_subgrid",
        "kind": 2,
        "importPath": "challenges.array.valid_sudoku",
        "description": "challenges.array.valid_sudoku",
        "peekOfCode": "def get_subgrid(board, i, j):\n    # We could do this manually one by one since there are only 3 rows.\n    subgrid = []\n    for m in range(3 * i, 3 * (i + 1)):\n        subgrid += board[m][3 * j : 3 * (j + 1)]\n    return subgrid",
        "detail": "challenges.array.valid_sudoku",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "challenges.bitwise_and_others.hamming_distance",
        "description": "challenges.bitwise_and_others.hamming_distance",
        "peekOfCode": "class Solution:\n    def hammingDistance_bitwise_1(self, x: int, y: int) -> int:\n        \"\"\"\n        2022-07-28 08:30:04\n        Runtime: 46 ms (52%)\n        Memory Usage: 13.9 MB (61%)\n        First attempt with bitwise operation.\n        1. Get xor between x and y. different digit becomes 1 and matching digit becomes 0.\n        2. While right-shifting xor, increment distance if xor's LSD is 1 (does not match)\n        \"\"\"",
        "detail": "challenges.bitwise_and_others.hamming_distance",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "challenges.bitwise_and_others.missing_number",
        "description": "challenges.bitwise_and_others.missing_number",
        "peekOfCode": "class Solution:\n    def missingNumber_combined_logic(self, nums: List[int]) -> int:\n        \"\"\"\n        Runtime: 141 ms (93%)\n        Memory Usage: 15.3 MB (35%)\n        Uses len(nums) instead of n so that when there is zero in the list,\n        we get the n + 1 as the missing number.\n        When there is no zero in the list, \n        we'll get zero as the missing number.\n        len(nums) == max_num except when the missing number is max_num + 1",
        "detail": "challenges.bitwise_and_others.missing_number",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "challenges.bitwise_and_others.number_of_one_bits",
        "description": "challenges.bitwise_and_others.number_of_one_bits",
        "peekOfCode": "class Solution:\n    def hammingWeight_transforms(self, n: int) -> int:\n        \"\"\"\n        2022-07-27 07:18:31\n        Runtime: 41 ms (70%)\n        Memory Usage: 13.9 MB (50%)\n        - bin(int) returns binary string with \"0b\" prefix. fastest.\n        \"\"\"\n        return len([x for x in str(bin(n)) if x == \"1\"])\n    def hammingWeight(self, n: int) -> int:",
        "detail": "challenges.bitwise_and_others.number_of_one_bits",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "challenges.bitwise_and_others.pascals_triangle",
        "description": "challenges.bitwise_and_others.pascals_triangle",
        "peekOfCode": "class Solution:\n    def generate_look_behind(self, numRows: int) -> List[List[int]]:\n        \"\"\"\n        2022-08-02 08:31:30\n        Runtime: 43 ms (64%)\n        Memory Usage: 13.9 MB (66%)\n        O(n^2) solution. could optimize by taking advantage of the array's symmetry.\n        but the difference wouldn't be much because the numRow has the upper bound of 30.\n        writing out the example with indexes helps us understand the pattern\n        j 0    1      2",
        "detail": "challenges.bitwise_and_others.pascals_triangle",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "challenges.bitwise_and_others.reverse_bits",
        "description": "challenges.bitwise_and_others.reverse_bits",
        "peekOfCode": "class Solution:\n    def reverseBits(self, n: int) -> int:\n        \"\"\"\n        2022-07-29 08:31:41\n        Runtime: 37 ms (86%)\n        Memory Usage: 13.9 MB (50%)\n        Do the for loop since the length of the binary string is fixed at 32.\n        - concat '1' to the result string if the lsd is 1, otherwise concat '0'\n        - right shift input to go to the next least-significant-digit\n        - convert the bin string into integer after the loop",
        "detail": "challenges.bitwise_and_others.reverse_bits",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "challenges.bitwise_and_others.valid_parentheses",
        "description": "challenges.bitwise_and_others.valid_parentheses",
        "peekOfCode": "class Solution:\n    def isValid_check_and_return(self, s: str) -> bool:\n        \"\"\"\n        2022-08-04 05:54:08\n        Runtime: 57 ms (29%)\n        Memory Usage: 13.8 MB (98%)\n        \"\"\"\n        stack = []\n        for c in s:\n            if c in (\"(\", \"[\", \"{\"):",
        "detail": "challenges.bitwise_and_others.valid_parentheses",
        "documentation": {}
    },
    {
        "label": "MinStack_keep_mins",
        "kind": 6,
        "importPath": "challenges.design.min_stack",
        "description": "challenges.design.min_stack",
        "peekOfCode": "class MinStack_keep_mins:\n    \"\"\"\n    2022-07-23 16:38:52\n    Runtime: 81 ms (72%)\n    Memory Usage: 17.8 MB (73%)\n    Only append to the min array when the value is leq to the last item\n    because we don't need to keep any values greater than the min value.\n    When any values greater than min gets popped off the stack, we don't need to make any changes to the min stack.\n    The only time we need to pop off the min stack is when the popped off value that matches the current min value.\n    \"\"\"",
        "detail": "challenges.design.min_stack",
        "documentation": {}
    },
    {
        "label": "FirstSolution",
        "kind": 6,
        "importPath": "challenges.design.shuffle_an_array",
        "description": "challenges.design.shuffle_an_array",
        "peekOfCode": "class FirstSolution:\n    \"\"\"\n    2022-07-23 15:08:34\n    Runtime: 267 ms (45%)\n    Memory Usage: 17.6 MB (40%)\n    \"\"\"\n    def __init__(self, nums: List[int]):\n        self.nums = nums\n    def reset(self) -> List[int]:\n        return self.nums",
        "detail": "challenges.design.shuffle_an_array",
        "documentation": {}
    },
    {
        "label": "SecondSolution",
        "kind": 6,
        "importPath": "challenges.design.shuffle_an_array",
        "description": "challenges.design.shuffle_an_array",
        "peekOfCode": "class SecondSolution:\n    \"\"\"\n    Runtime: 213 ms (71%)\n    Memory Usage: 17.5 MB (73%)\n    Create a copy at the instantiation time and shuffle them in place.\n    This one creates the list only once whereas the first solution creates new lists every time shuffle is called.\n    Read the constraint:\n    \"At most 104 calls in total will be made to reset and shuffle.\"\n    \"\"\"\n    def __init__(self, nums: List[int]):",
        "detail": "challenges.design.shuffle_an_array",
        "documentation": {}
    },
    {
        "label": "countTriplets_first_try",
        "kind": 2,
        "importPath": "challenges.dictionary_and_hashmaps.count_triplets.count_triplets",
        "description": "challenges.dictionary_and_hashmaps.count_triplets.count_triplets",
        "peekOfCode": "def countTriplets_first_try(arr, r):\n    \"\"\"\n    Only works for sorted array.\n    \"\"\"\n    nums = {}\n    for val in arr:\n        nums[val] = nums[val] + 1 if val in nums else 1\n    count = 0\n    # num is unique number\n    if r == 1:",
        "detail": "challenges.dictionary_and_hashmaps.count_triplets.count_triplets",
        "documentation": {}
    },
    {
        "label": "countTriplets_unsorted",
        "kind": 2,
        "importPath": "challenges.dictionary_and_hashmaps.count_triplets.count_triplets",
        "description": "challenges.dictionary_and_hashmaps.count_triplets.count_triplets",
        "peekOfCode": "def countTriplets_unsorted(arr, r):\n    \"\"\"\n    store a list of indexes for each number\n    {\n        4: [0, 3],\n        2: [1, 4],\n        1: [2, 5]\n    }\n    iterate from the lower number. Find n * r then check if the index is greater\n        - nested loop",
        "detail": "challenges.dictionary_and_hashmaps.count_triplets.count_triplets",
        "documentation": {}
    },
    {
        "label": "countTriplets_answer",
        "kind": 2,
        "importPath": "challenges.dictionary_and_hashmaps.count_triplets.count_triplets",
        "description": "challenges.dictionary_and_hashmaps.count_triplets.count_triplets",
        "peekOfCode": "def countTriplets_answer(arr, r):\n    count = 0\n    bWant = {}\n    cWant = {}\n    for key in arr:\n        if key in cWant:\n            # key is a cValue\n            c = key\n            # Increase count 'n' times\n            count += cWant[c]",
        "detail": "challenges.dictionary_and_hashmaps.count_triplets.count_triplets",
        "documentation": {}
    },
    {
        "label": "countTriplets_rework",
        "kind": 2,
        "importPath": "challenges.dictionary_and_hashmaps.count_triplets.count_triplets",
        "description": "challenges.dictionary_and_hashmaps.count_triplets.count_triplets",
        "peekOfCode": "def countTriplets_rework(numbers, r):\n    # Number of combinations that makes the complete geometric sequence in fhe form of a - b - c\n    count = 0\n    # Number of A's that needs B to complete the sequence. B: count(A)\n    # counting number of a's for each b eg. given [1, 1, 1, 2], { 2: 3 }\n    # -> target 2 has 3 previous numbers that becomes 2 when multiplied by r.\n    b_needed_by_as = {}\n    # Number of B's that needs C to complete the sequence. C: count(B)\n    c_needed_by_bs = {}\n    for curr_num in numbers:",
        "detail": "challenges.dictionary_and_hashmaps.count_triplets.count_triplets",
        "documentation": {}
    },
    {
        "label": "seconds",
        "kind": 5,
        "importPath": "challenges.dictionary_and_hashmaps.count_triplets.count_triplets",
        "description": "challenges.dictionary_and_hashmaps.count_triplets.count_triplets",
        "peekOfCode": "seconds = {}\nthirds = {}\ncurr_num = 1\nsecond = 1 * r = 2\nsecond is not in seconds: seconds = {2: 1}\ncurr_num is not in seconds\ncurr_num is not in thirds\ncurr_num = 2, second = 2 * 2 = 4\nsecond is not in seconds: seconds = {2: 1, 4: 1}\ncurr_num is in seconds:",
        "detail": "challenges.dictionary_and_hashmaps.count_triplets.count_triplets",
        "documentation": {}
    },
    {
        "label": "thirds",
        "kind": 5,
        "importPath": "challenges.dictionary_and_hashmaps.count_triplets.count_triplets",
        "description": "challenges.dictionary_and_hashmaps.count_triplets.count_triplets",
        "peekOfCode": "thirds = {}\ncurr_num = 1\nsecond = 1 * r = 2\nsecond is not in seconds: seconds = {2: 1}\ncurr_num is not in seconds\ncurr_num is not in thirds\ncurr_num = 2, second = 2 * 2 = 4\nsecond is not in seconds: seconds = {2: 1, 4: 1}\ncurr_num is in seconds:\n    second is not in thirds: thirds = {4: 1}",
        "detail": "challenges.dictionary_and_hashmaps.count_triplets.count_triplets",
        "documentation": {}
    },
    {
        "label": "curr_num",
        "kind": 5,
        "importPath": "challenges.dictionary_and_hashmaps.count_triplets.count_triplets",
        "description": "challenges.dictionary_and_hashmaps.count_triplets.count_triplets",
        "peekOfCode": "curr_num = 1\nsecond = 1 * r = 2\nsecond is not in seconds: seconds = {2: 1}\ncurr_num is not in seconds\ncurr_num is not in thirds\ncurr_num = 2, second = 2 * 2 = 4\nsecond is not in seconds: seconds = {2: 1, 4: 1}\ncurr_num is in seconds:\n    second is not in thirds: thirds = {4: 1}\ncurr_num is not in thirds",
        "detail": "challenges.dictionary_and_hashmaps.count_triplets.count_triplets",
        "documentation": {}
    },
    {
        "label": "second",
        "kind": 5,
        "importPath": "challenges.dictionary_and_hashmaps.count_triplets.count_triplets",
        "description": "challenges.dictionary_and_hashmaps.count_triplets.count_triplets",
        "peekOfCode": "second = 1 * r = 2\nsecond is not in seconds: seconds = {2: 1}\ncurr_num is not in seconds\ncurr_num is not in thirds\ncurr_num = 2, second = 2 * 2 = 4\nsecond is not in seconds: seconds = {2: 1, 4: 1}\ncurr_num is in seconds:\n    second is not in thirds: thirds = {4: 1}\ncurr_num is not in thirds\ncurr_num = 2, second = 4",
        "detail": "challenges.dictionary_and_hashmaps.count_triplets.count_triplets",
        "documentation": {}
    },
    {
        "label": "curr_num",
        "kind": 5,
        "importPath": "challenges.dictionary_and_hashmaps.count_triplets.count_triplets",
        "description": "challenges.dictionary_and_hashmaps.count_triplets.count_triplets",
        "peekOfCode": "curr_num = 2, second = 2 * 2 = 4\nsecond is not in seconds: seconds = {2: 1, 4: 1}\ncurr_num is in seconds:\n    second is not in thirds: thirds = {4: 1}\ncurr_num is not in thirds\ncurr_num = 2, second = 4\nsecond is in seconds: seconds = {2: 1, 4: 2}\ncurr_num is in seconds:\n    second is in thirds:\n\"\"\"",
        "detail": "challenges.dictionary_and_hashmaps.count_triplets.count_triplets",
        "documentation": {}
    },
    {
        "label": "curr_num",
        "kind": 5,
        "importPath": "challenges.dictionary_and_hashmaps.count_triplets.count_triplets",
        "description": "challenges.dictionary_and_hashmaps.count_triplets.count_triplets",
        "peekOfCode": "curr_num = 2, second = 4\nsecond is in seconds: seconds = {2: 1, 4: 2}\ncurr_num is in seconds:\n    second is in thirds:\n\"\"\"\ncount_triplets = countTriplets_rework",
        "detail": "challenges.dictionary_and_hashmaps.count_triplets.count_triplets",
        "documentation": {}
    },
    {
        "label": "count_triplets",
        "kind": 5,
        "importPath": "challenges.dictionary_and_hashmaps.count_triplets.count_triplets",
        "description": "challenges.dictionary_and_hashmaps.count_triplets.count_triplets",
        "peekOfCode": "count_triplets = countTriplets_rework",
        "detail": "challenges.dictionary_and_hashmaps.count_triplets.count_triplets",
        "documentation": {}
    },
    {
        "label": "test_sorted",
        "kind": 2,
        "importPath": "challenges.dictionary_and_hashmaps.count_triplets.count_triplets_tests",
        "description": "challenges.dictionary_and_hashmaps.count_triplets.count_triplets_tests",
        "peekOfCode": "def test_sorted(test_input, expected):\n    assert count_triplets(*test_input) == expected\n@pytest.mark.parametrize(\n    \"test_input,expected\",\n    [\n        (([4, 2, 2, 1], 2), 0),\n        (([4, 2, 1, 2], 2), 0),\n        (([4, 2, 1, 4, 2, 1], 2), 0),\n        (([1, 2, 4, 1], 2), 1),\n        (([4, 1, 2, 4], 2), 1),",
        "detail": "challenges.dictionary_and_hashmaps.count_triplets.count_triplets_tests",
        "documentation": {}
    },
    {
        "label": "test_unsorted",
        "kind": 2,
        "importPath": "challenges.dictionary_and_hashmaps.count_triplets.count_triplets_tests",
        "description": "challenges.dictionary_and_hashmaps.count_triplets.count_triplets_tests",
        "peekOfCode": "def test_unsorted(test_input, expected):\n    assert count_triplets(*test_input) == expected\ndef test_case_10():\n    \"\"\"\n    {\n        1: 9911\n        1000000000: 9939\n        100000: 10161\n        100: 9890\n        10: 10081",
        "detail": "challenges.dictionary_and_hashmaps.count_triplets.count_triplets_tests",
        "documentation": {}
    },
    {
        "label": "test_case_10",
        "kind": 2,
        "importPath": "challenges.dictionary_and_hashmaps.count_triplets.count_triplets_tests",
        "description": "challenges.dictionary_and_hashmaps.count_triplets.count_triplets_tests",
        "peekOfCode": "def test_case_10():\n    \"\"\"\n    {\n        1: 9911\n        1000000000: 9939\n        100000: 10161\n        100: 9890\n        10: 10081\n        10000000: 10094\n        100000000: 9814",
        "detail": "challenges.dictionary_and_hashmaps.count_triplets.count_triplets_tests",
        "documentation": {}
    },
    {
        "label": "sherlockAndAnagrams_wrong_math",
        "kind": 2,
        "importPath": "challenges.dictionary_and_hashmaps.sherlock_and_anagrams.sherlock_and_anagrams",
        "description": "challenges.dictionary_and_hashmaps.sherlock_and_anagrams.sherlock_and_anagrams",
        "peekOfCode": "def sherlockAndAnagrams_wrong_math(s):\n    # brute forcing\n    pairs = 0\n    for length in range(1, len(s)):\n        c = Counter()\n        for i in range(len(s) + 1 - length):\n            sub = s[i : i + length]\n            sub = \"\".join(sorted(sub))\n            c[sub] += 1\n        num_pairs = [int(factorial(count) / 2) for count in c.values() if count > 1]",
        "detail": "challenges.dictionary_and_hashmaps.sherlock_and_anagrams.sherlock_and_anagrams",
        "documentation": {}
    },
    {
        "label": "sherlockAndAnagrams_correct_math",
        "kind": 2,
        "importPath": "challenges.dictionary_and_hashmaps.sherlock_and_anagrams.sherlock_and_anagrams",
        "description": "challenges.dictionary_and_hashmaps.sherlock_and_anagrams.sherlock_and_anagrams",
        "peekOfCode": "def sherlockAndAnagrams_correct_math(s):\n    \"\"\"\n    2023-03-14 08:57:45\n    O(n^2) but works due to upper bound in input: len(s) <= 100\n    \"\"\"\n    # brute forcing\n    pairs = 0\n    for length in range(1, len(s)):\n        # this could be a plain dict\n        c = Counter()",
        "detail": "challenges.dictionary_and_hashmaps.sherlock_and_anagrams.sherlock_and_anagrams",
        "documentation": {}
    },
    {
        "label": "sherlock_and_anagrams",
        "kind": 5,
        "importPath": "challenges.dictionary_and_hashmaps.sherlock_and_anagrams.sherlock_and_anagrams",
        "description": "challenges.dictionary_and_hashmaps.sherlock_and_anagrams.sherlock_and_anagrams",
        "peekOfCode": "sherlock_and_anagrams = sherlockAndAnagrams_correct_math",
        "detail": "challenges.dictionary_and_hashmaps.sherlock_and_anagrams.sherlock_and_anagrams",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 2,
        "importPath": "challenges.dictionary_and_hashmaps.sherlock_and_anagrams.sherlock_and_anagrams_tests",
        "description": "challenges.dictionary_and_hashmaps.sherlock_and_anagrams.sherlock_and_anagrams_tests",
        "peekOfCode": "def test(test_input, expected):\n    assert sherlock_and_anagrams(test_input) == expected",
        "detail": "challenges.dictionary_and_hashmaps.sherlock_and_anagrams.sherlock_and_anagrams_tests",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "challenges.dynamic_programming.climbing_stairs",
        "description": "challenges.dynamic_programming.climbing_stairs",
        "peekOfCode": "class Solution:\n    def climbStairs_memo_bottom_up(self, n: int) -> int:\n        \"\"\"\n        Runtime: 32 ms (90%)\n        Memory Usage: 13.8 MB (96%)\n        At every decision point we can either step or skip -> \"binary decision tree\"\n        - Each non-null leaf counts as 1 and we stop either at 1 or 0\n        - At every node, the # of possibilities is the sum of possibilities from left and right child.\n        - There are duplicates of the same sub-trees -> use memoization.\n        './climbing_stairs_1.png'",
        "detail": "challenges.dynamic_programming.climbing_stairs",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "challenges.dynamic_programming.house_robber",
        "description": "challenges.dynamic_programming.house_robber",
        "peekOfCode": "class Solution:\n    def rob_look_back(self, nums: List[int]) -> int:\n        \"\"\"\n        2022-07-23 14:08:40\n        Runtime: 41 ms (72%)\n        Memory Usage: 13.8 MB (66%)\n        Finding max or min -> iterate while updating (dynamic programming)\n        1. If the max two steps before the current number + current number > the max one step before\n            -> update the max with the sum\n        2. else (if the max one step before is still greater than or equal to the current number + max two steps away)",
        "detail": "challenges.dynamic_programming.house_robber",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "challenges.dynamic_programming.max_profit",
        "description": "challenges.dynamic_programming.max_profit",
        "peekOfCode": "class Solution:\n    \"\"\"\n    Runtime: 1154 ms (85%)\n    Memory Usage: 25 MB (85%)\n    Finding min | max -> sliding window!\n    - keep track of min price and max profit while looping through the prices\n    - subtract min price from the current price ot update max profit\n    \"\"\"\n    def maxProfit(self, prices: List[int]) -> int:\n        min_price, max_profit = float(\"inf\"), 0",
        "detail": "challenges.dynamic_programming.max_profit",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "challenges.dynamic_programming.max_subarray",
        "description": "challenges.dynamic_programming.max_subarray",
        "peekOfCode": "class Solution:\n    def maxSubArray_add_and_remove(self, nums: List[int]) -> int:\n        \"\"\"\n        2022-07-21 08:34:29\n        Runtime: 1152 ms (42%)\n        Memory Usage: 27.7 MB (98%)\n        Loop through the list adding each number to the sum\n        if the sum <= 0, subarray up to that point doesn't contribute to the max.\n        - subtract that part\n        \"\"\"",
        "detail": "challenges.dynamic_programming.max_subarray",
        "documentation": {}
    },
    {
        "label": "hourglassSum_brute_force",
        "kind": 2,
        "importPath": "challenges.hourglass_sum.hourglass_sum",
        "description": "challenges.hourglass_sum.hourglass_sum",
        "peekOfCode": "def hourglassSum_brute_force(arr):\n    \"\"\"\n    2023-02-16 06:56:03\n    array range is limited so we can run in O(n).\n    - can be further optimized by subtracting prev columns/rows and\n      adding new columns/rows instead of summing again.\n    - but also there are only max 3 numbers in sum function,\n      so the pref gain is small.\n    \"\"\"\n    mx = -81",
        "detail": "challenges.hourglass_sum.hourglass_sum",
        "documentation": {}
    },
    {
        "label": "hourglass_sum",
        "kind": 5,
        "importPath": "challenges.hourglass_sum.hourglass_sum",
        "description": "challenges.hourglass_sum.hourglass_sum",
        "peekOfCode": "hourglass_sum = hourglassSum_brute_force",
        "detail": "challenges.hourglass_sum.hourglass_sum",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 2,
        "importPath": "challenges.hourglass_sum.hourglass_sum_tests",
        "description": "challenges.hourglass_sum.hourglass_sum_tests",
        "peekOfCode": "def test(test_input, expected):\n    assert hourglass_sum(test_input) == expected",
        "detail": "challenges.hourglass_sum.hourglass_sum_tests",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "challenges.linked_list.delete_node",
        "description": "challenges.linked_list.delete_node",
        "peekOfCode": "class Solution:\n    def deleteNode(self, node):\n        \"\"\"\n        2022-06-28T11:34:49.965Z\n        Runtime: 41 ms (90%)\n        Memory Usage: 14.4 MB (0%)\n        Because we're givin the removing node,\n        We can copy the next node into the current node and\n        the original next node becomes unreferenced.\n        eg. From A->B->C, remove A",
        "detail": "challenges.linked_list.delete_node",
        "documentation": {}
    },
    {
        "label": "ListNode",
        "kind": 6,
        "importPath": "challenges.linked_list.linked_list_cycle",
        "description": "challenges.linked_list.linked_list_cycle",
        "peekOfCode": "class ListNode:\n    def __init__(self, x):\n        self.val = x\n        self.next = None\nclass Solution:\n    def hasCycle_set(self, head: Optional[ListNode]) -> bool:\n        \"\"\"\n        2022-07-04 10:04:14\n        Runtime: 104 ms (22%)\n        Memory Usage: 18 MB (0%)",
        "detail": "challenges.linked_list.linked_list_cycle",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "challenges.linked_list.linked_list_cycle",
        "description": "challenges.linked_list.linked_list_cycle",
        "peekOfCode": "class Solution:\n    def hasCycle_set(self, head: Optional[ListNode]) -> bool:\n        \"\"\"\n        2022-07-04 10:04:14\n        Runtime: 104 ms (22%)\n        Memory Usage: 18 MB (0%)\n        Storing all nodes until we find the repeated one.\n        Uses linear space.\n        \"\"\"\n        s = set()",
        "detail": "challenges.linked_list.linked_list_cycle",
        "documentation": {}
    },
    {
        "label": "ListNode",
        "kind": 6,
        "importPath": "challenges.linked_list.merge_two_sorted_lists",
        "description": "challenges.linked_list.merge_two_sorted_lists",
        "peekOfCode": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\nclass Solution:\n    def mergeTwoLists_two_pointers(\n        self, list1: Optional[ListNode], list2: Optional[ListNode]\n    ) -> Optional[ListNode]:\n        \"\"\"\n        2022-07-02 17:24:52",
        "detail": "challenges.linked_list.merge_two_sorted_lists",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "challenges.linked_list.merge_two_sorted_lists",
        "description": "challenges.linked_list.merge_two_sorted_lists",
        "peekOfCode": "class Solution:\n    def mergeTwoLists_two_pointers(\n        self, list1: Optional[ListNode], list2: Optional[ListNode]\n    ) -> Optional[ListNode]:\n        \"\"\"\n        2022-07-02 17:24:52\n        Runtime: 42 ms (85%)\n        Memory Usage: 13.9 MB (79%)\n        Using one pointer to traverse, and the other to keep track of the other list.\n        Feel like I was lucky to come up with this. Practice more!",
        "detail": "challenges.linked_list.merge_two_sorted_lists",
        "documentation": {}
    },
    {
        "label": "ListNode",
        "kind": 6,
        "importPath": "challenges.linked_list.palindrome_linked_list",
        "description": "challenges.linked_list.palindrome_linked_list",
        "peekOfCode": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\nclass Solution:\n    def isPalindrome_reverse_and_compare(self, head: Optional[ListNode]) -> bool:\n        \"\"\"\n        2022-07-02 18:32:29\n        Runtime: 718 ms (99%)\n        Memory Usage: 31.3 MB (93%)",
        "detail": "challenges.linked_list.palindrome_linked_list",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "challenges.linked_list.palindrome_linked_list",
        "description": "challenges.linked_list.palindrome_linked_list",
        "peekOfCode": "class Solution:\n    def isPalindrome_reverse_and_compare(self, head: Optional[ListNode]) -> bool:\n        \"\"\"\n        2022-07-02 18:32:29\n        Runtime: 718 ms (99%)\n        Memory Usage: 31.3 MB (93%)\n        Using the previous reversing algorithm, reverse the fist half then compare nodes with the ones in the second half\n        \"\"\"\n        # get the length of the list in order to find the middle\n        n = 0",
        "detail": "challenges.linked_list.palindrome_linked_list",
        "documentation": {}
    },
    {
        "label": "ListNode",
        "kind": 6,
        "importPath": "challenges.linked_list.remove_nth_node_from_end_of_list",
        "description": "challenges.linked_list.remove_nth_node_from_end_of_list",
        "peekOfCode": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\nclass Solution:\n    def removeNthFromEnd_follow_behind(\n        self, head: Optional[ListNode], n: int\n    ) -> Optional[ListNode]:\n        \"\"\"\n        2022-06-29T11:57:03.359Z",
        "detail": "challenges.linked_list.remove_nth_node_from_end_of_list",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "challenges.linked_list.remove_nth_node_from_end_of_list",
        "description": "challenges.linked_list.remove_nth_node_from_end_of_list",
        "peekOfCode": "class Solution:\n    def removeNthFromEnd_follow_behind(\n        self, head: Optional[ListNode], n: int\n    ) -> Optional[ListNode]:\n        \"\"\"\n        2022-06-29T11:57:03.359Z\n        Runtime: 35 ms (90%)\n        Memory Usage: 13.9 MB (69%)\n        Using 3 pointers + 1 counter:\n        - i: counter to move left and pre behind right",
        "detail": "challenges.linked_list.remove_nth_node_from_end_of_list",
        "documentation": {}
    },
    {
        "label": "ListNode",
        "kind": 6,
        "importPath": "challenges.linked_list.reverse_linked_list",
        "description": "challenges.linked_list.reverse_linked_list",
        "peekOfCode": "class ListNode:\n    def __init__(self, val=0, next=None):\n        self.val = val\n        self.next = next\nclass Solution:\n    def reverseList_n_square(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        \"\"\"\n        2022-07-01T15:07:15.016Z\n        Naive iterative solution.\n        This one didn't pass the time limit for [5000 - x for x in range(5000)]",
        "detail": "challenges.linked_list.reverse_linked_list",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "challenges.linked_list.reverse_linked_list",
        "description": "challenges.linked_list.reverse_linked_list",
        "peekOfCode": "class Solution:\n    def reverseList_n_square(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        \"\"\"\n        2022-07-01T15:07:15.016Z\n        Naive iterative solution.\n        This one didn't pass the time limit for [5000 - x for x in range(5000)]\n        \"\"\"\n        if not head:\n            return\n        def swap(n1, n2):",
        "detail": "challenges.linked_list.reverse_linked_list",
        "documentation": {}
    },
    {
        "label": "BracketCombinationsTests",
        "kind": 6,
        "importPath": "challenges.math.tests.bracket_combinations_tests",
        "description": "challenges.math.tests.bracket_combinations_tests",
        "peekOfCode": "class BracketCombinationsTests(TestCase):\n    def setUp(self):\n        self.test_cases = [\n            (1, 1),\n            (2, 2),\n            (3, 5),\n            (4, 14),\n            (5, 42),\n            (6, 132),\n            (7, 429),",
        "detail": "challenges.math.tests.bracket_combinations_tests",
        "documentation": {}
    },
    {
        "label": "BracketCombinations_binary_decision_tree",
        "kind": 2,
        "importPath": "challenges.math.bracket_combinations",
        "description": "challenges.math.bracket_combinations",
        "peekOfCode": "def BracketCombinations_binary_decision_tree(num):\n    \"\"\"\n    2023-01-24 06:52:20\n    \"\"\"\n    def inner(num_open=num, num_closed=num):\n        # Ran out of either of brackets -> 1 decision from here\n        if num_open <= 0 or num_closed <= 0:\n            return 1\n        # If we have more remaining open bracket, we can branch out into 2 cases\n        if num_open > num_closed:",
        "detail": "challenges.math.bracket_combinations",
        "documentation": {}
    },
    {
        "label": "bracket_combinations_math",
        "kind": 2,
        "importPath": "challenges.math.bracket_combinations",
        "description": "challenges.math.bracket_combinations",
        "peekOfCode": "def bracket_combinations_math(num):\n    \"\"\"\n    000111\n    001011\n    001101\n    010011\n    010101\n    - must start with 0 and end with 1\n    - at any given index, there cannot be more 1s than 0s.\n    Permutation on all elements = (2 * num)! -> 6!",
        "detail": "challenges.math.bracket_combinations",
        "documentation": {}
    },
    {
        "label": "bracket_combinations",
        "kind": 5,
        "importPath": "challenges.math.bracket_combinations",
        "description": "challenges.math.bracket_combinations",
        "peekOfCode": "bracket_combinations = BracketCombinations_binary_decision_tree",
        "detail": "challenges.math.bracket_combinations",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "challenges.math.count_primes",
        "description": "challenges.math.count_primes",
        "peekOfCode": "class Solution:\n    def countPrimes_mark_off(self, n: int) -> int:\n        \"\"\"\n        2022-07-24 12:26:17\n        Runtime: 4051 ms (71%)\n        Memory Usage: 55.5 MB (55%)\n        Use n space to mark off to reduce the number of nested loop\n        Slow approach:\n        def is_prime(self, n):\n            # many conditions to reduce the amount of iteration",
        "detail": "challenges.math.count_primes",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "challenges.math.fizz_buzz",
        "description": "challenges.math.fizz_buzz",
        "peekOfCode": "class Solution:\n    def fizzBuzz(self, n: int) -> List[str]:\n        \"\"\"\n        2022-07-24 07:53:38\n        Runtime: 78 ms ( 26%)\n        Memory Usage: 14.9 MB (85%)\n        * Some answers in the higher percentile makes conditionals one-line.\n        \"\"\"\n        answer = []\n        for i in range(1, n + 1):",
        "detail": "challenges.math.fizz_buzz",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "challenges.math.power_of_three",
        "description": "challenges.math.power_of_three",
        "peekOfCode": "class Solution:\n    def isPowerOfThree_brute_force(self, n: int) -> bool:\n        \"\"\"\n        2022-07-25 07:47:01\n        Runtime: 200 ms (15%)\n        Memory Usage: 13.9 MB (57%)\n        Should've spent more time straightening out:\n        - the min condition to get into loop\n        - expected outcome at the end of the loop\n        \"\"\"",
        "detail": "challenges.math.power_of_three",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "challenges.math.roman_to_integer",
        "description": "challenges.math.roman_to_integer",
        "peekOfCode": "class Solution:\n    def romanToInt_right_to_left(self, s: str) -> int:\n        \"\"\"\n        2022-07-26 07:42:27\n        Runtime: 56 ms (83%)\n        Memory Usage: 13.8 MB (76%)\n        Iterate backward following hint\n        \"\"\"\n        TO_NUM = {\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000}\n        chars = list(s)",
        "detail": "challenges.math.roman_to_integer",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "challenges.sorting_and_searching.first_bad_version",
        "description": "challenges.sorting_and_searching.first_bad_version",
        "peekOfCode": "class Solution:\n    def firstBadVersion(self, n: int) -> int:\n        \"\"\"\n        2022-07-17 11:09:30\n        Runtime: 58 ms (44%)\n        Memory Usage: 13.9 MB (97%)\n        Look left every time the mid is bad. If left is good, return mid.\n        Slow because of extra API call when mid is bad.\n        eg. if the first version is bad, will make 2 * log(n) calls\n        looks like other solutions are utilizing caching (slow time, great space)",
        "detail": "challenges.sorting_and_searching.first_bad_version",
        "documentation": {}
    },
    {
        "label": "isBadVersion",
        "kind": 2,
        "importPath": "challenges.sorting_and_searching.first_bad_version",
        "description": "challenges.sorting_and_searching.first_bad_version",
        "peekOfCode": "def isBadVersion(version: int) -> bool:\n    pass\nclass Solution:\n    def firstBadVersion(self, n: int) -> int:\n        \"\"\"\n        2022-07-17 11:09:30\n        Runtime: 58 ms (44%)\n        Memory Usage: 13.9 MB (97%)\n        Look left every time the mid is bad. If left is good, return mid.\n        Slow because of extra API call when mid is bad.",
        "detail": "challenges.sorting_and_searching.first_bad_version",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "challenges.sorting_and_searching.merge_sorted_array",
        "description": "challenges.sorting_and_searching.merge_sorted_array",
        "peekOfCode": "class Solution:\n    def merge_two_pointers(\n        self, nums1: List[int], m: int, nums2: List[int], n: int\n    ) -> None:\n        \"\"\"\n        2022-07-15 07:29:40\n        Runtime: 58 ms (49%)\n        Memory Usage: 13.9 MB (86%)\n        First attempt & works -> room for improvement\n        - both arrays are already sorted",
        "detail": "challenges.sorting_and_searching.merge_sorted_array",
        "documentation": {}
    },
    {
        "label": "MinWindowSubstringTests",
        "kind": 6,
        "importPath": "challenges.strings.tests.min_window_substring_tests",
        "description": "challenges.strings.tests.min_window_substring_tests",
        "peekOfCode": "class MinWindowSubstringTests(TestCase):\n    def setUp(self):\n        self.cases = [\n            ([\"aaabaaddae\", \"aed\"], \"dae\"),\n            ([\"aabdccdbcacd\", \"aad\"], \"aabd\"),\n            ([\"aaaaaaaaa\", \"a\"], \"a\"),\n            ([\"aaffsfsfasfasfasfasfasfacasfafe\", \"fafe\"], \"fafe\"),\n            ([\"aaffsfsfasfasfasfasfasfacasfafe\", \"fafsf\"], \"affsf\"),\n            ([\"vvavereveaevafefaef\", \"vvev\"], \"vvave\"),\n            ([\"caae\", \"cae\"], \"caae\"),",
        "detail": "challenges.strings.tests.min_window_substring_tests",
        "documentation": {}
    },
    {
        "label": "QuestionMarksTests",
        "kind": 6,
        "importPath": "challenges.strings.tests.question_marks_tests",
        "description": "challenges.strings.tests.question_marks_tests",
        "peekOfCode": "class QuestionMarksTests(TestCase):\n    def test__false__no_add_upto_ten(self):\n        self.assertEqual(QuestionMarks(\"aa6?9\"), \"false\")\n    def test__false__no_three_question_marks_between_nums(self):\n        self.assertEqual(QuestionMarks(\"9???1???9??1???9\"), \"false\")\n    def test__true__three_question_marks_with_letters_in_between(self):\n        self.assertEqual(QuestionMarks(\"acc?7??sss?3rr1??????5\"), \"true\")\n        self.assertEqual(QuestionMarks(\"5??aaaaaaaaaaaaaaaaaaa?5?a??5\"), \"true\")\n    def test__true(self):\n        self.assertEqual(QuestionMarks(\"9???1???9???1???9\"), \"true\")",
        "detail": "challenges.strings.tests.question_marks_tests",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "challenges.strings.tests.test_longest_common_prefix",
        "description": "challenges.strings.tests.test_longest_common_prefix",
        "peekOfCode": "class Solution:\n    def longestCommonPrefix(self, strs: List[str]) -> str:\n        \"\"\"\n        Runtime: 42 ms (76%)\n        Memory Usage: 14 MB (0%)\n        \"\"\"\n        if len(strs) < 2:\n            return strs[0]\n        prefix = \"\"\n        strs.sort(key=len)",
        "detail": "challenges.strings.tests.test_longest_common_prefix",
        "documentation": {}
    },
    {
        "label": "FindIntersection_two_pointers",
        "kind": 2,
        "importPath": "challenges.strings.find_intersection",
        "description": "challenges.strings.find_intersection",
        "peekOfCode": "def FindIntersection_two_pointers(strArr):\n    \"\"\"\n    2023-01-17 07:10:58\n    O(n) time & space\n    - Could save space by not creating list and directly parsing from the string\n    \"\"\"\n    nums1 = [int(x) for x in strArr[0].split(\", \")]\n    nums2 = [int(x) for x in strArr[1].split(\", \")]\n    res = \"\"\n    p1 = p2 = 0",
        "detail": "challenges.strings.find_intersection",
        "documentation": {}
    },
    {
        "label": "FindIntersection_declarative",
        "kind": 2,
        "importPath": "challenges.strings.find_intersection",
        "description": "challenges.strings.find_intersection",
        "peekOfCode": "def FindIntersection_declarative(strArr):\n    \"\"\"\n    2023-01-18 07:24:57\n    O(nLog(n)) time and space\n    If we don't want to use two pointers,\n    Using set (linear) is faster than list comprehension (quadratic)\n    \"\"\"\n    # Don't map to int yet. Always wait until necessary\n    str_nums_set_1 = set(strArr[0].split(\", \"))\n    str_nums_set_2 = set(strArr[1].split(\", \"))",
        "detail": "challenges.strings.find_intersection",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "challenges.strings.first_unique_character_in_a_string",
        "description": "challenges.strings.first_unique_character_in_a_string",
        "peekOfCode": "class Solution:\n    def firstUniqChar_dict(self, s: str) -> int:\n        \"\"\"\n        2022-06-25T23:21:35.840Z\n        Runtime: 123 ms (76%)\n        Memory Usage: 15.6 MB (0%)\n        using dict to avoid O(n^2) for lookup.\n        \"\"\"\n        d = {}\n        for i, c in enumerate(s):",
        "detail": "challenges.strings.first_unique_character_in_a_string",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "challenges.strings.index_of",
        "description": "challenges.strings.index_of",
        "peekOfCode": "class Solution:\n    def strStr(self, haystack: str, needle: str) -> int:\n        \"\"\"\n        2022-06-27T00:42:21.134Z\n        Runtime: 29 ms (95%)\n        Memory Usage: 13.9 MB (15%)\n        \"\"\"\n        for i in range(len(haystack) - len(needle) + 1):\n            if haystack[i : i + len(needle)] == needle:\n                return i",
        "detail": "challenges.strings.index_of",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "challenges.strings.longest_common_prefix",
        "description": "challenges.strings.longest_common_prefix",
        "peekOfCode": "class Solution:\n    def longestCommonPrefix_sort(self, strs: List[str]) -> str:\n        \"\"\"\n        2022-08-24 20:51:37\n        Runtime: 66 ms (25%)\n        Memory Usage: 13.9 MB (50 %)\n        Used sort to pick the shortest str in the list.\n        slow since we're sorting the entire list first.\n        \"\"\"\n        strs.sort(key=len)",
        "detail": "challenges.strings.longest_common_prefix",
        "documentation": {}
    },
    {
        "label": "MinWindowSubstring__fail__only_comparing_same_length",
        "kind": 2,
        "importPath": "challenges.strings.min_window_substring",
        "description": "challenges.strings.min_window_substring",
        "peekOfCode": "def MinWindowSubstring__fail__only_comparing_same_length(strArr):\n    \"\"\"\n    2023-01-16 08:08:45\n    This doesn't work for:\n      - For input [\"aaabaaddae\", \"aed\"] the output was incorrect. The correct output is dae\n    because the substring can be longer than the second string. eg. substring can include\n    letters that don't belong to the substring but the letters around it do.\n    \"\"\"\n    sub_counter = Counter(strArr[1])\n    for i in range(len(strArr[0]) - len(strArr[1])):",
        "detail": "challenges.strings.min_window_substring",
        "documentation": {}
    },
    {
        "label": "MinWindowSubstring__fail__returns_duplicate_letters",
        "kind": 2,
        "importPath": "challenges.strings.min_window_substring",
        "description": "challenges.strings.min_window_substring",
        "peekOfCode": "def MinWindowSubstring__fail__returns_duplicate_letters(strArr):\n    \"\"\"\n    2023-01-16 08:56:23\n    This returns multiple duplicate letters when the target is a single letter.\n    We need to return the minimum substring.\n    1. For input [\"aaaaaaaaa\", \"a\"] the output was incorrect. The correct output is a\n    \"\"\"\n    sub_counter = Counter(strArr[1])\n    for i in range(1, len(strArr[0]) + 1):\n        curr_str = strArr[0][:i]",
        "detail": "challenges.strings.min_window_substring",
        "documentation": {}
    },
    {
        "label": "MinWindowSubstring_working_v1",
        "kind": 2,
        "importPath": "challenges.strings.min_window_substring",
        "description": "challenges.strings.min_window_substring",
        "peekOfCode": "def MinWindowSubstring_working_v1(strArr):\n    \"\"\"\n    2023-01-17 06:13:33\n    \"\"\"\n    target_counter = Counter(strArr[1])\n    # Find the substring by expanding it from the beginning\n    for i in range(len(strArr[0])):\n        substr = strArr[0][: i + 1]\n        if not (target_counter - Counter(substr)):\n            break",
        "detail": "challenges.strings.min_window_substring",
        "documentation": {}
    },
    {
        "label": "MinWindowSubstring_readable",
        "kind": 2,
        "importPath": "challenges.strings.min_window_substring",
        "description": "challenges.strings.min_window_substring",
        "peekOfCode": "def MinWindowSubstring_readable(strArr):\n    \"\"\"\n    2023-01-17 06:52:43\n    \"\"\"\n    master, target = strArr\n    target_counter = Counter(target)\n    for i in range(len(master)):\n        substr = master[: i + 1]\n        substr_includes_target = not target_counter - Counter(substr)\n        if substr_includes_target:",
        "detail": "challenges.strings.min_window_substring",
        "documentation": {}
    },
    {
        "label": "MinWindowSubstring_again",
        "kind": 2,
        "importPath": "challenges.strings.min_window_substring",
        "description": "challenges.strings.min_window_substring",
        "peekOfCode": "def MinWindowSubstring_again(strArr):\n    \"\"\"\n    2023-01-28 12:17:16\n    \"\"\"\n    master, chars = strArr\n    chars_counter = Counter(chars)\n    for right in range(1, len(master)):\n        sub_counter = Counter(master[: right + 1])\n        if not chars_counter - sub_counter:\n            break",
        "detail": "challenges.strings.min_window_substring",
        "documentation": {}
    },
    {
        "label": "MinWindowSubstring_without_recreating_counters",
        "kind": 2,
        "importPath": "challenges.strings.min_window_substring",
        "description": "challenges.strings.min_window_substring",
        "peekOfCode": "def MinWindowSubstring_without_recreating_counters(strArr):\n    \"\"\"\n    2023-01-28 15:23:22\n    Counter can be used like dict:\n    - check if a key exists\n    - access individual key-value\n    Improvements:\n    - Create an empty counter once before looping\n    - Only increment counter if the current character is included in chars counter\n      and stop when the counter start to cover chars_counter.",
        "detail": "challenges.strings.min_window_substring",
        "documentation": {}
    },
    {
        "label": "MinWindowSubstring",
        "kind": 5,
        "importPath": "challenges.strings.min_window_substring",
        "description": "challenges.strings.min_window_substring",
        "peekOfCode": "MinWindowSubstring = MinWindowSubstring_without_recreating_counters",
        "detail": "challenges.strings.min_window_substring",
        "documentation": {}
    },
    {
        "label": "QuestionsMarks_linear",
        "kind": 2,
        "importPath": "challenges.strings.question_marks",
        "description": "challenges.strings.question_marks",
        "peekOfCode": "def QuestionsMarks_linear(strParam: str):\n    \"\"\"\n    2023-01-20 06:46:41\n    \"\"\"\n    pair_sum = 0\n    question_marks = 0\n    has_pair = False\n    for i, char in enumerate(strParam):\n        if char.isnumeric():\n            if pair_sum == 0:",
        "detail": "challenges.strings.question_marks",
        "documentation": {}
    },
    {
        "label": "question_marks_simpler",
        "kind": 2,
        "importPath": "challenges.strings.question_marks",
        "description": "challenges.strings.question_marks",
        "peekOfCode": "def question_marks_simpler(string: str):\n    \"\"\"\n    2023-01-20 06:46:48\n    \"\"\"\n    num = 11  # no single number can be added to this and make 10\n    question_marks = 0\n    has_pair = False\n    for char in string:\n        if char.isnumeric():\n            if num + int(char) == 10:",
        "detail": "challenges.strings.question_marks",
        "documentation": {}
    },
    {
        "label": "question_marks_unnecessary_conditions",
        "kind": 2,
        "importPath": "challenges.strings.question_marks",
        "description": "challenges.strings.question_marks",
        "peekOfCode": "def question_marks_unnecessary_conditions(strParam):\n    \"\"\"\n    2023-01-25 07:24:40\n    The requirement says \"3 question marks between every pair of two numbers that add up to 10.\"\n    So, we don't need to look behind to check if it was a question mark.\n    WE JUST NEED TO FIND A PAIR OF NUMBER THAT ADD UP TO 10!!!\n    \"\"\"\n    num_before_q = 0  # initializing with 0 won't affect the result\n    num_q = 0\n    has_pair = False",
        "detail": "challenges.strings.question_marks",
        "documentation": {}
    },
    {
        "label": "question_marks_better",
        "kind": 2,
        "importPath": "challenges.strings.question_marks",
        "description": "challenges.strings.question_marks",
        "peekOfCode": "def question_marks_better(strParam):\n    \"\"\"\n    2023-01-26 06:59:13\n    readable\n    \"\"\"\n    prevNum = 11  # so that the sum with any single digit number cannot be 10\n    questions = 0\n    has_pair = False\n    for c in strParam:\n        if c.isnumeric():",
        "detail": "challenges.strings.question_marks",
        "documentation": {}
    },
    {
        "label": "QuestionMarks",
        "kind": 5,
        "importPath": "challenges.strings.question_marks",
        "description": "challenges.strings.question_marks",
        "peekOfCode": "QuestionMarks = question_marks_better",
        "detail": "challenges.strings.question_marks",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "challenges.strings.reverse_integer",
        "description": "challenges.strings.reverse_integer",
        "peekOfCode": "class Solution:\n    def reverse(self, x: int) -> int:\n        \"\"\"\n        2022-06-25T22:52:39.033Z\n        Runtime: 19 ms (99.96%)\n        Memory Usage: 14 MB (0%)\n        If the system indeed does not allow int64, we could use try and except to return 0\n        \"\"\"\n        is_negative = x < 0\n        x = list(str(x).lstrip(\"-\"))",
        "detail": "challenges.strings.reverse_integer",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "challenges.strings.reverse_string",
        "description": "challenges.strings.reverse_string",
        "peekOfCode": "class Solution:\n    def reverseString_swap(self, s: List[str]) -> None:\n        \"\"\"\n        2022-06-25T22:18:53.379Z\n        Runtime: 314 ms (39%)\n        Memory Usage: 18.3 MB (87%)\n        without using s.reverse()\n        \"\"\"\n        for i in range(len(s) // 2):\n            t = s[i]",
        "detail": "challenges.strings.reverse_string",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "challenges.strings.string_to_integer_atoi",
        "description": "challenges.strings.string_to_integer_atoi",
        "peekOfCode": "class Solution:\n    \"\"\"\n    2022-06-26T21:54:41.866Z\n    Runtime: 32 ms (97%)\n    Memory Usage: 13.8 MB (79%)\n    We can probably make this simpler by taking advantage of s.length <= 200\n    Could use this at the end:\n    min(max(num, -pow(2, 31)), pow(2, 31) - 1)\n    \"\"\"\n    def myAtoi(self, s: str) -> int:",
        "detail": "challenges.strings.string_to_integer_atoi",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "challenges.strings.valid_anagram",
        "description": "challenges.strings.valid_anagram",
        "peekOfCode": "class Solution:\n    def isAnagram_counter(self, s: str, t: str) -> bool:\n        \"\"\"\n        2022-06-26T02:25:33.257Z\n        Runtime: 40 ms (98%)\n        Memory Usage: 14.5 MB (34%)\n        Python counters are comparable by values.\n        \"\"\"\n        return Counter(s) == Counter(t)\n    def isAnagram_constant_memory(self, s: str, t: str) -> bool:",
        "detail": "challenges.strings.valid_anagram",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "challenges.strings.valid_palindrome",
        "description": "challenges.strings.valid_palindrome",
        "peekOfCode": "class Solution:\n    def isPalindrome_two_pointers(self, s: str) -> bool:\n        \"\"\"\n        2022-06-26T02:44:57.775Z\n        Runtime: 68 ms (57%)\n        Memory Usage: 14.4 MB (86%)\n        use two pointers and return early\n        \"\"\"\n        an = \"qazwsxedcrfvtgbyhnujmikolp1234567890\"\n        s = s.lower()",
        "detail": "challenges.strings.valid_palindrome",
        "documentation": {}
    },
    {
        "label": "TreeConstructorTests",
        "kind": 6,
        "importPath": "challenges.trees.tests.tree_constructor_tests",
        "description": "challenges.trees.tests.tree_constructor_tests",
        "peekOfCode": "class TreeConstructorTests(TestCase):\n    def test__true(self):\n        self.assertEqual(\n            tree_constructor([\"(1,2)\", \"(2,4)\", \"(5,7)\", \"(7,2)\", \"(9,5)\"]), \"true\"\n        )\n    def test__true__double_digit(self):\n        self.assertEqual(\n            tree_constructor([\"(2,3)\", \"(1,2)\", \"(4,9)\", \"(9,3)\", \"(12,9)\", \"(6,4)\"]),\n            \"true\",\n        )",
        "detail": "challenges.trees.tests.tree_constructor_tests",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "challenges.trees.level_order",
        "description": "challenges.trees.level_order",
        "peekOfCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution:\n    def levelOrder_bfs(self, root: Optional[TreeNode]) -> List[List[int]]:\n        \"\"\"\n        Runtime: 32 ms (97%)\n        Memory Usage: 14.2 MB (84%)",
        "detail": "challenges.trees.level_order",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "challenges.trees.level_order",
        "description": "challenges.trees.level_order",
        "peekOfCode": "class Solution:\n    def levelOrder_bfs(self, root: Optional[TreeNode]) -> List[List[int]]:\n        \"\"\"\n        Runtime: 32 ms (97%)\n        Memory Usage: 14.2 MB (84%)\n        Use BFS to create a list of sibling nodes inside inner loop\n        and append the list to the result in outer loop\n        \"\"\"\n        if root is None:\n            return None",
        "detail": "challenges.trees.level_order",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "challenges.trees.max_depth_of_binary_tree",
        "description": "challenges.trees.max_depth_of_binary_tree",
        "peekOfCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution:\n    def maxDepth_recursion_bubble_up(self, root: Optional[TreeNode]) -> int:\n        \"\"\"\n        2022-12-01 09:00:24\n        Creates inner function to count the depth on the way down and bubble up the max_depth when it reaches the leaf node",
        "detail": "challenges.trees.max_depth_of_binary_tree",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "challenges.trees.max_depth_of_binary_tree",
        "description": "challenges.trees.max_depth_of_binary_tree",
        "peekOfCode": "class Solution:\n    def maxDepth_recursion_bubble_up(self, root: Optional[TreeNode]) -> int:\n        \"\"\"\n        2022-12-01 09:00:24\n        Creates inner function to count the depth on the way down and bubble up the max_depth when it reaches the leaf node\n        \"\"\"\n        def inner(node, curr_depth):\n            if not node:\n                return curr_depth - 1\n            return max(",
        "detail": "challenges.trees.max_depth_of_binary_tree",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "challenges.trees.sorted_array_to_bst",
        "description": "challenges.trees.sorted_array_to_bst",
        "peekOfCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution:\n    def sortedArrayToBST_recursion(self, nums: List[int]) -> Optional[TreeNode]:\n        \"\"\"\n        2022-07-14 08:38:00\n        Runtime: 119 ms (64%)",
        "detail": "challenges.trees.sorted_array_to_bst",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "challenges.trees.sorted_array_to_bst",
        "description": "challenges.trees.sorted_array_to_bst",
        "peekOfCode": "class Solution:\n    def sortedArrayToBST_recursion(self, nums: List[int]) -> Optional[TreeNode]:\n        \"\"\"\n        2022-07-14 08:38:00\n        Runtime: 119 ms (64%)\n        Memory Usage: 15.6 MB (83%)\n        Keep finding middle node from the subarray and attach it to the parent as left or right child.\n        Call itself twice with the middle node as parent and the left and right subarray.\n        \"\"\"\n        mid = len(nums) // 2",
        "detail": "challenges.trees.sorted_array_to_bst",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "challenges.trees.symmetric_tree",
        "description": "challenges.trees.symmetric_tree",
        "peekOfCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution:\n    def isSymmetric_bfs(self, root: Optional[TreeNode]) -> bool:\n        \"\"\"\n        2022-07-11 08:03:48\n        Runtime: 38 ms (87%)",
        "detail": "challenges.trees.symmetric_tree",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "challenges.trees.symmetric_tree",
        "description": "challenges.trees.symmetric_tree",
        "peekOfCode": "class Solution:\n    def isSymmetric_bfs(self, root: Optional[TreeNode]) -> bool:\n        \"\"\"\n        2022-07-11 08:03:48\n        Runtime: 38 ms (87%)\n        Memory Usage:14 MB (60%)\n        Using BFS to get all nodes on the same level and check symmetry\n        This algo checks from the root node and returns as soon as finding non-symmetric level.\n        \"\"\"\n        def check(nodes):",
        "detail": "challenges.trees.symmetric_tree",
        "documentation": {}
    },
    {
        "label": "tree_constructor",
        "kind": 2,
        "importPath": "challenges.trees.tree_constructor",
        "description": "challenges.trees.tree_constructor",
        "peekOfCode": "def tree_constructor(strArr):\n    \"\"\"\n    2023-01-23 07:35:25\n    Checks for following:\n    - All children should be unique\n    - All parents should have max one left/right child\n    - All nodes are connected and have 1 root node.\n    Examples\n    Input: [\"(1,2)\", \"(2,4)\", \"(5,7)\", \"(7,2)\", \"(9,5)\"]\n    Output: true",
        "detail": "challenges.trees.tree_constructor",
        "documentation": {}
    },
    {
        "label": "tree_constructor_2",
        "kind": 2,
        "importPath": "challenges.trees.tree_constructor",
        "description": "challenges.trees.tree_constructor",
        "peekOfCode": "def tree_constructor_2(strArr):\n    \"\"\"\n    2023-01-28 21:48:20\n    \"\"\"\n    parents_dict = {}\n    child_set = set()\n    for c, p in map(eval, strArr):\n        if c in child_set:\n            return \"false\"\n        child_set.add(c)",
        "detail": "challenges.trees.tree_constructor",
        "documentation": {}
    },
    {
        "label": "TreeNode",
        "kind": 6,
        "importPath": "challenges.trees.validate_binary_search_tree",
        "description": "challenges.trees.validate_binary_search_tree",
        "peekOfCode": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nclass Solution:\n    def isValidBST_minmax(self, root: Optional[TreeNode]) -> bool:\n        \"\"\"\n        Runtime: 76 ms (88%)\n        Memory Usage: 16.6 MB (45%)",
        "detail": "challenges.trees.validate_binary_search_tree",
        "documentation": {}
    },
    {
        "label": "Solution",
        "kind": 6,
        "importPath": "challenges.trees.validate_binary_search_tree",
        "description": "challenges.trees.validate_binary_search_tree",
        "peekOfCode": "class Solution:\n    def isValidBST_minmax(self, root: Optional[TreeNode]) -> bool:\n        \"\"\"\n        Runtime: 76 ms (88%)\n        Memory Usage: 16.6 MB (45%)\n        pass minmax when calling helper recursively with left or right child.\n        minmax value is updated in relation to the current value and the position of the children.\n        eg. when calling with left child, max value would be the current node value and the min value\n        the most recently updated min value from the ancestors.\n        The range gets narrower as traversing down on a binary tree",
        "detail": "challenges.trees.validate_binary_search_tree",
        "documentation": {}
    },
    {
        "label": "BaseLinkedList",
        "kind": 6,
        "importPath": "data-structures.linked-lists.singly-linked-list.linked_list",
        "description": "data-structures.linked-lists.singly-linked-list.linked_list",
        "peekOfCode": "class BaseLinkedList(ABC):\n    length: int\n    head: Union[Node, None]\n    tail: Union[Node, None]\n    def __init__(self):\n        self.length = 0\n        self.head = None\n        self.tail = None\n        super().__init__()\n    # @property",
        "detail": "data-structures.linked-lists.singly-linked-list.linked_list",
        "documentation": {}
    },
    {
        "label": "SinglyLinkedList",
        "kind": 6,
        "importPath": "data-structures.linked-lists.singly-linked-list.linked_list",
        "description": "data-structures.linked-lists.singly-linked-list.linked_list",
        "peekOfCode": "class SinglyLinkedList(BaseLinkedList):\n    def __init__(self):\n        super().__init__()\n    def push(self, value):\n        node = Node(value)\n        if self.head is None or self.tail is None:\n            self.head = node\n            self.tail = node\n        else:\n            self.tail.next = node",
        "detail": "data-structures.linked-lists.singly-linked-list.linked_list",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "data-structures.linked-lists.singly-linked-list.linked_list",
        "description": "data-structures.linked-lists.singly-linked-list.linked_list",
        "peekOfCode": "T = TypeVar(\"T\")\nclass BaseLinkedList(ABC):\n    length: int\n    head: Union[Node, None]\n    tail: Union[Node, None]\n    def __init__(self):\n        self.length = 0\n        self.head = None\n        self.tail = None\n        super().__init__()",
        "detail": "data-structures.linked-lists.singly-linked-list.linked_list",
        "documentation": {}
    },
    {
        "label": "Node",
        "kind": 6,
        "importPath": "data-structures.linked-lists.singly-linked-list.node",
        "description": "data-structures.linked-lists.singly-linked-list.node",
        "peekOfCode": "class Node:\n    next: Union[None, Node]\n    def __init__(self, value: Any):\n        self.value = value\n        self.next = None",
        "detail": "data-structures.linked-lists.singly-linked-list.node",
        "documentation": {}
    },
    {
        "label": "SinglyLinkedListTestCase",
        "kind": 6,
        "importPath": "data-structures.linked-lists.singly-linked-list.test_linked_list",
        "description": "data-structures.linked-lists.singly-linked-list.test_linked_list",
        "peekOfCode": "class SinglyLinkedListTestCase(unittest.TestCase):\n    def setUp(self) -> None:\n        self.sut = SinglyLinkedList()\n    def test_properties(self):\n        self.assertEqual(self.sut.length, 0)\n        self.assertEqual(self.sut.head, None)\n        self.assertEqual(self.sut.tail, None)\n    def test_push(self):\n        self.sut.push(1)\n        self.sut.push(2)",
        "detail": "data-structures.linked-lists.singly-linked-list.test_linked_list",
        "documentation": {}
    },
    {
        "label": "NodeTestCase",
        "kind": 6,
        "importPath": "data-structures.linked-lists.singly-linked-list.test_node",
        "description": "data-structures.linked-lists.singly-linked-list.test_node",
        "peekOfCode": "class NodeTestCase(unittest.TestCase):\n    def test_properties(self):\n        node = Node(1)\n        self.assertEqual(node.value, 1)\n        self.assertEqual(node.next, None)\n    def test_can_link(self):\n        first = Node(1)\n        second = Node(2)\n        third = Node(3)\n        first.next = second",
        "detail": "data-structures.linked-lists.singly-linked-list.test_node",
        "documentation": {}
    },
    {
        "label": "binary_search_recursive",
        "kind": 2,
        "importPath": "problem-solving-patterns.divide-and-conquer-pattern.divide_and_conquer_pattern",
        "description": "problem-solving-patterns.divide-and-conquer-pattern.divide_and_conquer_pattern",
        "peekOfCode": "def binary_search_recursive(items: List[int], value: int) -> int:\n    def inner(head_index: int, tail_index: int) -> int:\n        if head_index > tail_index:\n            return -1\n        mid_index = floor((tail_index + head_index) / 2)\n        mid_value = items[mid_index]\n        if value == mid_value:\n            return mid_index\n        elif mid_value < value:\n            return inner(mid_index + 1, tail_index)",
        "detail": "problem-solving-patterns.divide-and-conquer-pattern.divide_and_conquer_pattern",
        "documentation": {}
    },
    {
        "label": "binary_search_iterative",
        "kind": 2,
        "importPath": "problem-solving-patterns.divide-and-conquer-pattern.divide_and_conquer_pattern",
        "description": "problem-solving-patterns.divide-and-conquer-pattern.divide_and_conquer_pattern",
        "peekOfCode": "def binary_search_iterative(items: List[int], value: int) -> int:\n    head_index = 0\n    tail_index = len(items) - 1\n    while head_index <= tail_index:\n        mid_index = floor((head_index + tail_index) / 2)\n        mid_value = items[mid_index]\n        if mid_value == value:\n            return mid_index\n        elif mid_value < value:\n            head_index = mid_index + 1",
        "detail": "problem-solving-patterns.divide-and-conquer-pattern.divide_and_conquer_pattern",
        "documentation": {}
    },
    {
        "label": "BinarySearchRecursiveTestCase",
        "kind": 6,
        "importPath": "problem-solving-patterns.divide-and-conquer-pattern.test_divide_and_conquer_pattern",
        "description": "problem-solving-patterns.divide-and-conquer-pattern.test_divide_and_conquer_pattern",
        "peekOfCode": "class BinarySearchRecursiveTestCase(unittest.TestCase):\n    def test_value_in_the_middle(self):\n        self.assertEqual(binary_search_recursive([1, 2, 3, 4, 5, 6], 4), 3)\n    def test_value_at_the_end(self):\n        self.assertEqual(binary_search_recursive([1, 2, 3, 4, 5, 6], 6), 5)\n    def test_value_not_found(self):\n        self.assertEqual(binary_search_recursive([1, 2, 3, 4, 5, 6], 7), -1)\n    def test_single_value(self):\n        self.assertEqual(binary_search_recursive([1], 1), 0)\nclass BinarySearchIterativeTestCase(unittest.TestCase):",
        "detail": "problem-solving-patterns.divide-and-conquer-pattern.test_divide_and_conquer_pattern",
        "documentation": {}
    },
    {
        "label": "BinarySearchIterativeTestCase",
        "kind": 6,
        "importPath": "problem-solving-patterns.divide-and-conquer-pattern.test_divide_and_conquer_pattern",
        "description": "problem-solving-patterns.divide-and-conquer-pattern.test_divide_and_conquer_pattern",
        "peekOfCode": "class BinarySearchIterativeTestCase(unittest.TestCase):\n    def test_value_in_the_middle(self):\n        self.assertEqual(binary_search_iterative([1, 2, 3, 4, 5, 6], 4), 3)\n    def test_value_at_the_end(self):\n        self.assertEqual(binary_search_iterative([1, 2, 3, 4, 5, 6], 6), 5)\n    def test_value_not_found(self):\n        self.assertEqual(binary_search_iterative([1, 2, 3, 4, 5, 6], 7), -1)\n    def test_single_value(self):\n        self.assertEqual(binary_search_iterative([1], 1), 0)",
        "detail": "problem-solving-patterns.divide-and-conquer-pattern.test_divide_and_conquer_pattern",
        "documentation": {}
    },
    {
        "label": "same_naive",
        "kind": 2,
        "importPath": "problem-solving-patterns.frequency-counter-pattern.frequency_counter_pattern",
        "description": "problem-solving-patterns.frequency-counter-pattern.frequency_counter_pattern",
        "peekOfCode": "def same_naive(arr1: List[int], arr2: List[int]) -> bool:\n    \"\"\"O(n^2) implementation\"\"\"\n    if len(arr1) != len(arr2):\n        return False\n    arr2_copy = arr2.copy()  # don't mutate the input list\n    for item in arr1:\n        try:\n            # removes item from arr2 with O(n)\n            arr2_copy.remove(item**2)\n        except ValueError:",
        "detail": "problem-solving-patterns.frequency-counter-pattern.frequency_counter_pattern",
        "documentation": {}
    },
    {
        "label": "same",
        "kind": 2,
        "importPath": "problem-solving-patterns.frequency-counter-pattern.frequency_counter_pattern",
        "description": "problem-solving-patterns.frequency-counter-pattern.frequency_counter_pattern",
        "peekOfCode": "def same(arr1: List[int], arr2: List[int]) -> bool:\n    \"\"\"O(n) using hashmap to comapre the two lists\"\"\"\n    dict_1 = get_frequency_dict(arr1)\n    dict_2 = get_frequency_dict(arr2)\n    if len(dict_1) != len(dict_2):\n        return False\n    for item in dict_1:\n        try:\n            # Python raises KeyError if key is not found in dict\n            # and it can have any type as the key so we can do math ops directly",
        "detail": "problem-solving-patterns.frequency-counter-pattern.frequency_counter_pattern",
        "documentation": {}
    },
    {
        "label": "get_frequency_dict",
        "kind": 2,
        "importPath": "problem-solving-patterns.frequency-counter-pattern.frequency_counter_pattern",
        "description": "problem-solving-patterns.frequency-counter-pattern.frequency_counter_pattern",
        "peekOfCode": "def get_frequency_dict(list: List[Union[str, int]]):\n    frequency_dict = {}\n    for item in list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    return frequency_dict\ndef is_anagram(str1: str, str2: str) -> bool:\n    \"\"\"Determines if two strings are anagram",
        "detail": "problem-solving-patterns.frequency-counter-pattern.frequency_counter_pattern",
        "documentation": {}
    },
    {
        "label": "is_anagram",
        "kind": 2,
        "importPath": "problem-solving-patterns.frequency-counter-pattern.frequency_counter_pattern",
        "description": "problem-solving-patterns.frequency-counter-pattern.frequency_counter_pattern",
        "peekOfCode": "def is_anagram(str1: str, str2: str) -> bool:\n    \"\"\"Determines if two strings are anagram\n    Returns true if two empty strings are passed\n    Args:\n        str1 (str): First string to compare\n        str2 (str): Second string to compare\n    Returns:\n        bool: whether or not the given strings are anagram\n    \"\"\"\n    if len(str1) != len(str2):",
        "detail": "problem-solving-patterns.frequency-counter-pattern.frequency_counter_pattern",
        "documentation": {}
    },
    {
        "label": "same_frequency",
        "kind": 2,
        "importPath": "problem-solving-patterns.frequency-counter-pattern.frequency_counter_pattern",
        "description": "problem-solving-patterns.frequency-counter-pattern.frequency_counter_pattern",
        "peekOfCode": "def same_frequency(num1: int, num2: int) -> bool:\n    \"\"\"Determines if two numbers have the same frequencies of digits\n    eg. same_frequency(182, 281) -> True, same_frequency(24, 14) -> False\n    Args:\n        num1 (int): First number to compare\n        num2 (int): Second number to compare\n    Returns:\n        bool: whether or not the given numbers have the same frequencies of digits\n    \"\"\"\n    if get_number_of_digits(num1) != get_number_of_digits(num2):",
        "detail": "problem-solving-patterns.frequency-counter-pattern.frequency_counter_pattern",
        "documentation": {}
    },
    {
        "label": "get_digit_frequency_dict",
        "kind": 2,
        "importPath": "problem-solving-patterns.frequency-counter-pattern.frequency_counter_pattern",
        "description": "problem-solving-patterns.frequency-counter-pattern.frequency_counter_pattern",
        "peekOfCode": "def get_digit_frequency_dict(num: int) -> Dict[int, int]:\n    digits = num_to_digits(num)\n    dict = {}\n    for digit in digits:\n        try:\n            if dict[digit]:\n                dict[digit] += 1\n        except KeyError:\n            dict[digit] = 1\n    return dict",
        "detail": "problem-solving-patterns.frequency-counter-pattern.frequency_counter_pattern",
        "documentation": {}
    },
    {
        "label": "num_to_digits",
        "kind": 2,
        "importPath": "problem-solving-patterns.frequency-counter-pattern.frequency_counter_pattern",
        "description": "problem-solving-patterns.frequency-counter-pattern.frequency_counter_pattern",
        "peekOfCode": "def num_to_digits(num: int) -> List[int]:\n    # O(1) instead of O(n) using list.insert(0, val)\n    # https://stackoverflow.com/a/8538295\n    digits_queue = deque()\n    while num > 0:\n        digit = num % 10\n        digits_queue.appendleft(digit)\n        num = math.floor(num / 10)\n    return list(digits_queue)\ndef get_number_of_digits(num: int) -> int:",
        "detail": "problem-solving-patterns.frequency-counter-pattern.frequency_counter_pattern",
        "documentation": {}
    },
    {
        "label": "get_number_of_digits",
        "kind": 2,
        "importPath": "problem-solving-patterns.frequency-counter-pattern.frequency_counter_pattern",
        "description": "problem-solving-patterns.frequency-counter-pattern.frequency_counter_pattern",
        "peekOfCode": "def get_number_of_digits(num: int) -> int:\n    return math.floor(math.log10(num)) + 1\ndef are_there_duplicates(*args: Any) -> bool:\n    dict = {}\n    for arg in args:\n        try:\n            dict[arg] += 1\n        except KeyError:\n            dict[arg] = 1\n    return True if any([dict[arg] > 1 for arg in args]) else False",
        "detail": "problem-solving-patterns.frequency-counter-pattern.frequency_counter_pattern",
        "documentation": {}
    },
    {
        "label": "are_there_duplicates",
        "kind": 2,
        "importPath": "problem-solving-patterns.frequency-counter-pattern.frequency_counter_pattern",
        "description": "problem-solving-patterns.frequency-counter-pattern.frequency_counter_pattern",
        "peekOfCode": "def are_there_duplicates(*args: Any) -> bool:\n    dict = {}\n    for arg in args:\n        try:\n            dict[arg] += 1\n        except KeyError:\n            dict[arg] = 1\n    return True if any([dict[arg] > 1 for arg in args]) else False",
        "detail": "problem-solving-patterns.frequency-counter-pattern.frequency_counter_pattern",
        "documentation": {}
    },
    {
        "label": "TestStringMethods",
        "kind": 6,
        "importPath": "problem-solving-patterns.frequency-counter-pattern.test_frequency_counter_pattern",
        "description": "problem-solving-patterns.frequency-counter-pattern.test_frequency_counter_pattern",
        "peekOfCode": "class TestStringMethods(unittest.TestCase):\n    def test_upper(self):\n        self.assertEqual(\"foo\".upper(), \"FOO\")\n    def test_isupper(self):\n        self.assertTrue(\"FOO\".isupper())\n        self.assertFalse(\"Foo\".isupper())\n    def test_split(self):\n        s = \"hello world\"\n        self.assertEqual(s.split(), [\"hello\", \"world\"])\n        # check that s.split fails when the separator is not a string",
        "detail": "problem-solving-patterns.frequency-counter-pattern.test_frequency_counter_pattern",
        "documentation": {}
    },
    {
        "label": "SameTestCase",
        "kind": 6,
        "importPath": "problem-solving-patterns.frequency-counter-pattern.test_frequency_counter_pattern",
        "description": "problem-solving-patterns.frequency-counter-pattern.test_frequency_counter_pattern",
        "peekOfCode": "class SameTestCase(unittest.TestCase):\n    def test_success(self):\n        arr_1 = [1, 2, 3]\n        arr_2 = [4, 1, 9]\n        self.assertTrue(same_naive(arr_1, arr_2))\n        self.assertTrue(same(arr_1, arr_2))\n    def test_number_of_items_fail(self):\n        arr_1 = [1, 2, 3]\n        arr_2 = [1, 9]\n        self.assertFalse(same_naive(arr_1, arr_2))",
        "detail": "problem-solving-patterns.frequency-counter-pattern.test_frequency_counter_pattern",
        "documentation": {}
    },
    {
        "label": "IsAnagramTestCase",
        "kind": 6,
        "importPath": "problem-solving-patterns.frequency-counter-pattern.test_frequency_counter_pattern",
        "description": "problem-solving-patterns.frequency-counter-pattern.test_frequency_counter_pattern",
        "peekOfCode": "class IsAnagramTestCase(unittest.TestCase):\n    def test_success(self):\n        self.assertTrue(is_anagram(\"anagram\", \"nagaram\"))\n        self.assertTrue(is_anagram(\"qwerty\", \"qeyrwt\"))\n        self.assertTrue(is_anagram(\"texttwisttime\", \"timetwisttext\"))\n    def test_two_empty_strings(self):\n        self.assertTrue(is_anagram(\"\", \"\"))\n    def test_frequency_fail(self):\n        self.assertFalse(is_anagram(\"aaz\", \"zza\"))\n    def test_same_length_fail(self):",
        "detail": "problem-solving-patterns.frequency-counter-pattern.test_frequency_counter_pattern",
        "documentation": {}
    },
    {
        "label": "SameFrequencyTestCase",
        "kind": 6,
        "importPath": "problem-solving-patterns.frequency-counter-pattern.test_frequency_counter_pattern",
        "description": "problem-solving-patterns.frequency-counter-pattern.test_frequency_counter_pattern",
        "peekOfCode": "class SameFrequencyTestCase(unittest.TestCase):\n    def test_success(self):\n        self.assertTrue(same_frequency(182, 281))\n    def test_different_number_fail(self):\n        self.assertFalse(same_frequency(123, 234))\n    def test_different_frequency_fail(self):\n        self.assertFalse(same_frequency(112, 122))\nclass AreThereDuplicatesTestCase(unittest.TestCase):\n    def test_int_success(self):\n        self.assertTrue(are_there_duplicates(1, 2, 3, 1))",
        "detail": "problem-solving-patterns.frequency-counter-pattern.test_frequency_counter_pattern",
        "documentation": {}
    },
    {
        "label": "AreThereDuplicatesTestCase",
        "kind": 6,
        "importPath": "problem-solving-patterns.frequency-counter-pattern.test_frequency_counter_pattern",
        "description": "problem-solving-patterns.frequency-counter-pattern.test_frequency_counter_pattern",
        "peekOfCode": "class AreThereDuplicatesTestCase(unittest.TestCase):\n    def test_int_success(self):\n        self.assertTrue(are_there_duplicates(1, 2, 3, 1))\n    def test_str_success(self):\n        self.assertTrue(are_there_duplicates(\"a\", \"b\", \"c\", \"a\"))\n    def test_no_duplicates_fail(self):\n        self.assertFalse(are_there_duplicates(1, 2, 3))",
        "detail": "problem-solving-patterns.frequency-counter-pattern.test_frequency_counter_pattern",
        "documentation": {}
    },
    {
        "label": "sum_zero",
        "kind": 2,
        "importPath": "problem-solving-patterns.multiple-pointers-pattern.multiple_pointers_pattern",
        "description": "problem-solving-patterns.multiple-pointers-pattern.multiple_pointers_pattern",
        "peekOfCode": "def sum_zero(integers: List[int]) -> Union[List[int], None]:\n    i = 0\n    j = len(integers) - 1\n    while i < j and i <= 0 and j >= 0:\n        sum = integers[i] + integers[j]\n        if sum < 0:\n            i += 1\n        elif sum > 0:\n            j -= 1\n        else:",
        "detail": "problem-solving-patterns.multiple-pointers-pattern.multiple_pointers_pattern",
        "documentation": {}
    },
    {
        "label": "count_unique_values",
        "kind": 2,
        "importPath": "problem-solving-patterns.multiple-pointers-pattern.multiple_pointers_pattern",
        "description": "problem-solving-patterns.multiple-pointers-pattern.multiple_pointers_pattern",
        "peekOfCode": "def count_unique_values(sorted_ints: List[int]) -> int:\n    if len(sorted_ints) == 0:\n        return 0\n    # If there is at least one item in the list, it should count as a unique value\n    count = 1\n    i = 0\n    j = 1\n    while j < len(sorted_ints):\n        if sorted_ints[i] == sorted_ints[j]:\n            j += 1",
        "detail": "problem-solving-patterns.multiple-pointers-pattern.multiple_pointers_pattern",
        "documentation": {}
    },
    {
        "label": "are_there_duplicates",
        "kind": 2,
        "importPath": "problem-solving-patterns.multiple-pointers-pattern.multiple_pointers_pattern",
        "description": "problem-solving-patterns.multiple-pointers-pattern.multiple_pointers_pattern",
        "peekOfCode": "def are_there_duplicates(*args: Any):\n    sorted_args = list(args)\n    sorted_args.sort()\n    i = 1\n    while i < len(args):\n        if sorted_args[i - 1] == sorted_args[i]:\n            return True\n        else:\n            i += 1\n    return False",
        "detail": "problem-solving-patterns.multiple-pointers-pattern.multiple_pointers_pattern",
        "documentation": {}
    },
    {
        "label": "average_pair",
        "kind": 2,
        "importPath": "problem-solving-patterns.multiple-pointers-pattern.multiple_pointers_pattern",
        "description": "problem-solving-patterns.multiple-pointers-pattern.multiple_pointers_pattern",
        "peekOfCode": "def average_pair(sorted_ints: List[int], target_avg: float) -> bool:\n    if len(sorted_ints) < 2:\n        return False\n    i = 0\n    j = len(sorted_ints) - 1\n    while i < j:\n        avg = (sorted_ints[i] + sorted_ints[j]) / 2\n        if avg > target_avg:\n            j -= 1\n        elif avg < target_avg:",
        "detail": "problem-solving-patterns.multiple-pointers-pattern.multiple_pointers_pattern",
        "documentation": {}
    },
    {
        "label": "is_subsequence",
        "kind": 2,
        "importPath": "problem-solving-patterns.multiple-pointers-pattern.multiple_pointers_pattern",
        "description": "problem-solving-patterns.multiple-pointers-pattern.multiple_pointers_pattern",
        "peekOfCode": "def is_subsequence(str1: str, str2: str) -> bool:\n    index1 = 0\n    index2 = 0\n    while index1 < len(str1) and index2 < len(str2):\n        if str1[index1] == str2[index2]:\n            index1 += 1\n            index2 += 1\n        else:\n            index2 += 1\n    # we found all characters in str1 in str2",
        "detail": "problem-solving-patterns.multiple-pointers-pattern.multiple_pointers_pattern",
        "documentation": {}
    },
    {
        "label": "SumZeroTestCase",
        "kind": 6,
        "importPath": "problem-solving-patterns.multiple-pointers-pattern.test_multiple_pointers_pattern",
        "description": "problem-solving-patterns.multiple-pointers-pattern.test_multiple_pointers_pattern",
        "peekOfCode": "class SumZeroTestCase(unittest.TestCase):\n    def test_returns_first_pair_where_sum_is_zero(self):\n        self.assertEqual(sum_zero([-3, -2, -1, 0, 1, 2, 3]), [-3, 3])\n    def test_pair_not_found(self):\n        self.assertIsNone(sum_zero([-2, 0, 1, 3]))\n        self.assertIsNone(sum_zero([1, 2, 3]))\n    def test_one_zero(self):\n        self.assertIsNone(sum_zero([0]))\n    def test_two_zeros(self):\n        self.assertEqual(sum_zero([0, 0]), [0, 0])",
        "detail": "problem-solving-patterns.multiple-pointers-pattern.test_multiple_pointers_pattern",
        "documentation": {}
    },
    {
        "label": "CountUniqueValues",
        "kind": 6,
        "importPath": "problem-solving-patterns.multiple-pointers-pattern.test_multiple_pointers_pattern",
        "description": "problem-solving-patterns.multiple-pointers-pattern.test_multiple_pointers_pattern",
        "peekOfCode": "class CountUniqueValues(unittest.TestCase):\n    def test_success(self):\n        self.assertEqual(count_unique_values([1, 1, 1, 1, 1, 2]), 2)\n        self.assertEqual(count_unique_values([1, 2, 3, 4, 4, 4, 7, 7, 12, 12, 13]), 7)\n        self.assertEqual(count_unique_values([-2, -1, -1, 0, 1]), 4)\n    def test_empty_list(self):\n        self.assertEqual(count_unique_values([]), 0)\nclass AreThereDuplicatesTestCase(unittest.TestCase):\n    def test_number_duplicates(self):\n        self.assertTrue(are_there_duplicates(1, 2, 2))",
        "detail": "problem-solving-patterns.multiple-pointers-pattern.test_multiple_pointers_pattern",
        "documentation": {}
    },
    {
        "label": "AreThereDuplicatesTestCase",
        "kind": 6,
        "importPath": "problem-solving-patterns.multiple-pointers-pattern.test_multiple_pointers_pattern",
        "description": "problem-solving-patterns.multiple-pointers-pattern.test_multiple_pointers_pattern",
        "peekOfCode": "class AreThereDuplicatesTestCase(unittest.TestCase):\n    def test_number_duplicates(self):\n        self.assertTrue(are_there_duplicates(1, 2, 2))\n    def test_string_duplicates(self):\n        self.assertTrue(are_there_duplicates(\"a\", \"b\", \"c\", \"a\"))\n    def test_no_duplicates(self):\n        self.assertFalse(are_there_duplicates(1, 2, 3))\nclass AveragePairTestCase(unittest.TestCase):\n    def test_found_pair(self):\n        self.assertTrue(average_pair([1, 2, 3], 2.5))",
        "detail": "problem-solving-patterns.multiple-pointers-pattern.test_multiple_pointers_pattern",
        "documentation": {}
    },
    {
        "label": "AveragePairTestCase",
        "kind": 6,
        "importPath": "problem-solving-patterns.multiple-pointers-pattern.test_multiple_pointers_pattern",
        "description": "problem-solving-patterns.multiple-pointers-pattern.test_multiple_pointers_pattern",
        "peekOfCode": "class AveragePairTestCase(unittest.TestCase):\n    def test_found_pair(self):\n        self.assertTrue(average_pair([1, 2, 3], 2.5))\n        self.assertTrue(average_pair([1, 3, 3, 5, 6, 7, 10, 12, 19], 8))\n    def test_no_pair(self):\n        self.assertFalse(average_pair([-1, 0, 3, 4, 5, 6], 4.1))\n    def test_empty_list(self):\n        self.assertFalse(average_pair([], 4))\n    def test_one_integer(self):\n        self.assertFalse(average_pair([1], 1))",
        "detail": "problem-solving-patterns.multiple-pointers-pattern.test_multiple_pointers_pattern",
        "documentation": {}
    },
    {
        "label": "IsSubsequenceTestCase",
        "kind": 6,
        "importPath": "problem-solving-patterns.multiple-pointers-pattern.test_multiple_pointers_pattern",
        "description": "problem-solving-patterns.multiple-pointers-pattern.test_multiple_pointers_pattern",
        "peekOfCode": "class IsSubsequenceTestCase(unittest.TestCase):\n    def test_str1_in_str2(self):\n        self.assertTrue(is_subsequence(\"hello\", \"hello world\"))\n    def test_inserted_characters(self):\n        self.assertTrue(is_subsequence(\"sing\", \"sting\"))\n        self.assertTrue(is_subsequence(\"abc\", \"abracadabra\"))\n    def test_character_order_changed(self):\n        self.assertFalse(is_subsequence(\"abc\", \"acb\"))",
        "detail": "problem-solving-patterns.multiple-pointers-pattern.test_multiple_pointers_pattern",
        "documentation": {}
    },
    {
        "label": "max_subarray_sum",
        "kind": 2,
        "importPath": "problem-solving-patterns.sliding-window-pattern.sliding_window_pattern",
        "description": "problem-solving-patterns.sliding-window-pattern.sliding_window_pattern",
        "peekOfCode": "def max_subarray_sum(numbers: List[int], size: int) -> Union[int, None]:\n    \"\"\"Calculates the maximum sum of the subarray of the given size\n    Args:\n        numbers: a list of integers\n        size: the size fo subarray\n    Returns:\n        int: the sum of the subarray. None if the array is empty\n    \"\"\"\n    if size > len(numbers):\n        return None",
        "detail": "problem-solving-patterns.sliding-window-pattern.sliding_window_pattern",
        "documentation": {}
    },
    {
        "label": "where_to_grow",
        "kind": 2,
        "importPath": "problem-solving-patterns.sliding-window-pattern.sliding_window_pattern",
        "description": "problem-solving-patterns.sliding-window-pattern.sliding_window_pattern",
        "peekOfCode": "def where_to_grow(numbers: List[int], head_index: int, tail_index: int) -> int:\n    try:\n        left = numbers[head_index - 1]\n    except IndexError:\n        left = -1\n    try:\n        right = numbers[tail_index + 1]\n    except IndexError:\n        right = -1\n    if left < 0 and right < 0:",
        "detail": "problem-solving-patterns.sliding-window-pattern.sliding_window_pattern",
        "documentation": {}
    },
    {
        "label": "min_subarray_len",
        "kind": 2,
        "importPath": "problem-solving-patterns.sliding-window-pattern.sliding_window_pattern",
        "description": "problem-solving-patterns.sliding-window-pattern.sliding_window_pattern",
        "peekOfCode": "def min_subarray_len(numbers: List[int], min: int) -> int:\n    # Invalidate and return early!\n    if sum(numbers) < min:\n        return 0\n    subarray_len = 0\n    subarray_sum = 0\n    try:\n        max_number = max(numbers)\n    except ValueError:  # given an empty list\n        return 0",
        "detail": "problem-solving-patterns.sliding-window-pattern.sliding_window_pattern",
        "documentation": {}
    },
    {
        "label": "find_longest_substring",
        "kind": 2,
        "importPath": "problem-solving-patterns.sliding-window-pattern.sliding_window_pattern",
        "description": "problem-solving-patterns.sliding-window-pattern.sliding_window_pattern",
        "peekOfCode": "def find_longest_substring(string: str) -> int:\n    substring_head_index = 0\n    longest_substring_length = 0\n    last_seen_char_indices = {}\n    for i, char in enumerate(string):\n        def update_longest_substring_length():\n            nonlocal longest_substring_length\n            current_substring_length = i - substring_head_index + 1\n            longest_substring_length = (\n                current_substring_length",
        "detail": "problem-solving-patterns.sliding-window-pattern.sliding_window_pattern",
        "documentation": {}
    },
    {
        "label": "MaxSubarraySumTestCase",
        "kind": 6,
        "importPath": "problem-solving-patterns.sliding-window-pattern.test_sliding_window_pattern",
        "description": "problem-solving-patterns.sliding-window-pattern.test_sliding_window_pattern",
        "peekOfCode": "class MaxSubarraySumTestCase(unittest.TestCase):\n    def test_success(self):\n        array = [1, 2, 5, 2, 8, 1, 5]\n        self.assertEqual(max_subarray_sum(array, 2), 10)\n        self.assertEqual(max_subarray_sum(array, 4), 17)\n        self.assertEqual(max_subarray_sum(array, 1), 8)\n    def test_empty_array_returns_none(self):\n        self.assertIsNone(max_subarray_sum([], 4))\n    def test_subarray_bigger_than_array(self):\n        self.assertIsNone(max_subarray_sum([1, 2], 3))",
        "detail": "problem-solving-patterns.sliding-window-pattern.test_sliding_window_pattern",
        "documentation": {}
    },
    {
        "label": "MinSubarrayLenTestCase",
        "kind": 6,
        "importPath": "problem-solving-patterns.sliding-window-pattern.test_sliding_window_pattern",
        "description": "problem-solving-patterns.sliding-window-pattern.test_sliding_window_pattern",
        "peekOfCode": "class MinSubarrayLenTestCase(unittest.TestCase):\n    def test_success(self):\n        self.assertEqual(min_subarray_len([2, 3, 1, 2, 4, 3], 7), 2)\n        self.assertEqual(min_subarray_len([2, 1, 6, 5, 4], 9), 2)\n        self.assertEqual(\n            min_subarray_len([3, 1, 7, 11, 2, 9, 8, 21, 62, 33, 19], 52), 1\n        )\n        self.assertEqual(min_subarray_len([4, 3, 3, 8, 1, 2, 3], 11), 2)\n        self.assertEqual(min_subarray_len([1, 4, 16, 22, 5, 7, 8, 9, 10], 39), 3)\n        self.assertEqual(min_subarray_len([1, 4, 16, 22, 5, 7, 8, 9, 10], 55), 5)",
        "detail": "problem-solving-patterns.sliding-window-pattern.test_sliding_window_pattern",
        "documentation": {}
    },
    {
        "label": "FindLongestSubstringTestCase",
        "kind": 6,
        "importPath": "problem-solving-patterns.sliding-window-pattern.test_sliding_window_pattern",
        "description": "problem-solving-patterns.sliding-window-pattern.test_sliding_window_pattern",
        "peekOfCode": "class FindLongestSubstringTestCase(unittest.TestCase):\n    def test_success(self):\n        self.assertEqual(find_longest_substring(\"thisisawesome\"), 6)\n        self.assertEqual(find_longest_substring(\"thecatinthehat\"), 7)\n        self.assertEqual(find_longest_substring(\"longestsubstring\"), 8)\n        self.assertEqual(find_longest_substring(\"thisishowwedoit\"), 6)\n    def test_empty_string(self):\n        self.assertEqual(find_longest_substring(\"\"), 0)\n    def test_duplicated_letters(self):\n        self.assertEqual(find_longest_substring(\"bbb\"), 1)",
        "detail": "problem-solving-patterns.sliding-window-pattern.test_sliding_window_pattern",
        "documentation": {}
    },
    {
        "label": "collect_odd_values",
        "kind": 2,
        "importPath": "recursion.recursion",
        "description": "recursion.recursion",
        "peekOfCode": "def collect_odd_values(numbers: List[int]) -> List[int]:\n    result = []\n    def inner(index: int):\n        if index == len(numbers):\n            return\n        if numbers[index] % 2 != 0:\n            result.append(numbers[index])\n        inner(index + 1)\n    inner(0)\n    return result",
        "detail": "recursion.recursion",
        "documentation": {}
    },
    {
        "label": "collect_odd_values_pure",
        "kind": 2,
        "importPath": "recursion.recursion",
        "description": "recursion.recursion",
        "peekOfCode": "def collect_odd_values_pure(numbers: List[int]) -> List[int]:\n    new_list = []\n    if len(numbers) == 0:\n        return []\n    if numbers[0] % 2 != 0:\n        new_list.append(numbers[0])\n    return new_list + collect_odd_values_pure(numbers[1:])\ndef power(base: int, exponent: int) -> int:\n    if exponent == 0:\n        return 1",
        "detail": "recursion.recursion",
        "documentation": {}
    },
    {
        "label": "power",
        "kind": 2,
        "importPath": "recursion.recursion",
        "description": "recursion.recursion",
        "peekOfCode": "def power(base: int, exponent: int) -> int:\n    if exponent == 0:\n        return 1\n    return base * power(base, exponent - 1)\ndef factorial(num: int) -> int:\n    if num == 0:\n        return 1\n    return num * factorial(num - 1)\ndef product_of_array(numbers: List[int]) -> int:\n    if not numbers:",
        "detail": "recursion.recursion",
        "documentation": {}
    },
    {
        "label": "factorial",
        "kind": 2,
        "importPath": "recursion.recursion",
        "description": "recursion.recursion",
        "peekOfCode": "def factorial(num: int) -> int:\n    if num == 0:\n        return 1\n    return num * factorial(num - 1)\ndef product_of_array(numbers: List[int]) -> int:\n    if not numbers:\n        raise Exception(\"cannot pass an empty list\")\n    result = 1\n    def inner(numbers):\n        nonlocal result",
        "detail": "recursion.recursion",
        "documentation": {}
    },
    {
        "label": "product_of_array",
        "kind": 2,
        "importPath": "recursion.recursion",
        "description": "recursion.recursion",
        "peekOfCode": "def product_of_array(numbers: List[int]) -> int:\n    if not numbers:\n        raise Exception(\"cannot pass an empty list\")\n    result = 1\n    def inner(numbers):\n        nonlocal result\n        if not numbers:\n            return\n        result = result * numbers[0]\n        inner(numbers[1:])",
        "detail": "recursion.recursion",
        "documentation": {}
    },
    {
        "label": "sum_range",
        "kind": 2,
        "importPath": "recursion.recursion",
        "description": "recursion.recursion",
        "peekOfCode": "def sum_range(num: int) -> int:\n    if num == 0:\n        return 0\n    return num + sum_range(num - 1)\ndef fib(num: int) -> int:\n    if num < 3:\n        return 1\n    return fib(num - 1) + fib(num - 2)\ndef reverse(string: str) -> str:\n    if not string:",
        "detail": "recursion.recursion",
        "documentation": {}
    },
    {
        "label": "fib",
        "kind": 2,
        "importPath": "recursion.recursion",
        "description": "recursion.recursion",
        "peekOfCode": "def fib(num: int) -> int:\n    if num < 3:\n        return 1\n    return fib(num - 1) + fib(num - 2)\ndef reverse(string: str) -> str:\n    if not string:\n        return \"\"\n    return string[len(string) - 1] + reverse(string[0:-1])\ndef is_palindrome(string: str) -> bool:\n    if len(string) <= 1:",
        "detail": "recursion.recursion",
        "documentation": {}
    },
    {
        "label": "reverse",
        "kind": 2,
        "importPath": "recursion.recursion",
        "description": "recursion.recursion",
        "peekOfCode": "def reverse(string: str) -> str:\n    if not string:\n        return \"\"\n    return string[len(string) - 1] + reverse(string[0:-1])\ndef is_palindrome(string: str) -> bool:\n    if len(string) <= 1:\n        return True\n    if string[0] != string[-1]:\n        return False\n    return True and is_palindrome(string[1:-1])",
        "detail": "recursion.recursion",
        "documentation": {}
    },
    {
        "label": "is_palindrome",
        "kind": 2,
        "importPath": "recursion.recursion",
        "description": "recursion.recursion",
        "peekOfCode": "def is_palindrome(string: str) -> bool:\n    if len(string) <= 1:\n        return True\n    if string[0] != string[-1]:\n        return False\n    return True and is_palindrome(string[1:-1])\nT = TypeVar(\"T\")\ndef some_recursive(arr: List[T], cb: Callable[[T], bool]) -> bool:\n    if not arr:\n        return False",
        "detail": "recursion.recursion",
        "documentation": {}
    },
    {
        "label": "some_recursive",
        "kind": 2,
        "importPath": "recursion.recursion",
        "description": "recursion.recursion",
        "peekOfCode": "def some_recursive(arr: List[T], cb: Callable[[T], bool]) -> bool:\n    if not arr:\n        return False\n    return cb(arr[0]) or some_recursive(arr[1:], cb)\ndef flatten_helper(arr: Union[List[T], T]) -> List[T]:\n    result = []\n    def inner(inner_array: List[T]) -> None:\n        for item in inner_array:\n            if isinstance(item, list):\n                inner(item)",
        "detail": "recursion.recursion",
        "documentation": {}
    },
    {
        "label": "flatten_helper",
        "kind": 2,
        "importPath": "recursion.recursion",
        "description": "recursion.recursion",
        "peekOfCode": "def flatten_helper(arr: Union[List[T], T]) -> List[T]:\n    result = []\n    def inner(inner_array: List[T]) -> None:\n        for item in inner_array:\n            if isinstance(item, list):\n                inner(item)\n            else:\n                result.append(item)\n    inner(arr)\n    return result",
        "detail": "recursion.recursion",
        "documentation": {}
    },
    {
        "label": "flatten_pure",
        "kind": 2,
        "importPath": "recursion.recursion",
        "description": "recursion.recursion",
        "peekOfCode": "def flatten_pure(arr: Union[List[T], T]) -> List[T]:\n    if not isinstance(arr, list):\n        return [arr]\n    if len(arr) == 0:\n        return []\n    # python also returns an empty list when slicing from index out of range\n    return flatten_pure(arr[0]) + flatten_pure(arr[1:])\ndef capitalize_first(arr: List[str]) -> List[str]:\n    result = []\n    def inner(arr: List[str]) -> None:",
        "detail": "recursion.recursion",
        "documentation": {}
    },
    {
        "label": "capitalize_first",
        "kind": 2,
        "importPath": "recursion.recursion",
        "description": "recursion.recursion",
        "peekOfCode": "def capitalize_first(arr: List[str]) -> List[str]:\n    result = []\n    def inner(arr: List[str]) -> None:\n        if not arr:\n            return\n        first_item = arr[0]\n        capitalized_first_item = first_item[0].upper() + first_item[1:]\n        result.append(capitalized_first_item)\n        inner(arr[1:])\n    inner(arr)",
        "detail": "recursion.recursion",
        "documentation": {}
    },
    {
        "label": "nested_even_sum",
        "kind": 2,
        "importPath": "recursion.recursion",
        "description": "recursion.recursion",
        "peekOfCode": "def nested_even_sum(obj: dict) -> int:\n    sum = 0\n    def inner(obj: dict) -> None:\n        if not obj:\n            return\n        nonlocal sum\n        for _, value in obj.items():\n            if isinstance(value, int) and value % 2 == 0:\n                sum += value\n            elif isinstance(value, dict):",
        "detail": "recursion.recursion",
        "documentation": {}
    },
    {
        "label": "capitalize_words",
        "kind": 2,
        "importPath": "recursion.recursion",
        "description": "recursion.recursion",
        "peekOfCode": "def capitalize_words(words: List[str]) -> List[str]:\n    result = []\n    def inner(words: List[str]) -> None:\n        if not words:\n            return\n        first_word = words[0]\n        capitalized = first_word.upper()\n        result.append(capitalized)\n        inner(words[1:])\n    inner(words)",
        "detail": "recursion.recursion",
        "documentation": {}
    },
    {
        "label": "stringify_numbers",
        "kind": 2,
        "importPath": "recursion.recursion",
        "description": "recursion.recursion",
        "peekOfCode": "def stringify_numbers(obj: dict) -> dict:\n    copied_obj = deepcopy(obj)\n    def inner(obj: dict) -> None:\n        if not obj:\n            return\n        for key, value in obj.items():\n            # bool is subclass of int in python\n            if isinstance(value, bool):\n                continue\n            elif isinstance(value, int):",
        "detail": "recursion.recursion",
        "documentation": {}
    },
    {
        "label": "collect_strings",
        "kind": 2,
        "importPath": "recursion.recursion",
        "description": "recursion.recursion",
        "peekOfCode": "def collect_strings(obj: Any) -> List[str]:\n    result = []\n    def inner(obj: dict):\n        if not obj:\n            return\n        for _, val in obj.items():\n            if isinstance(val, str):\n                result.append(val)\n            elif isinstance(val, dict):\n                inner(val)",
        "detail": "recursion.recursion",
        "documentation": {}
    },
    {
        "label": "T",
        "kind": 5,
        "importPath": "recursion.recursion",
        "description": "recursion.recursion",
        "peekOfCode": "T = TypeVar(\"T\")\ndef some_recursive(arr: List[T], cb: Callable[[T], bool]) -> bool:\n    if not arr:\n        return False\n    return cb(arr[0]) or some_recursive(arr[1:], cb)\ndef flatten_helper(arr: Union[List[T], T]) -> List[T]:\n    result = []\n    def inner(inner_array: List[T]) -> None:\n        for item in inner_array:\n            if isinstance(item, list):",
        "detail": "recursion.recursion",
        "documentation": {}
    },
    {
        "label": "CollectOddValuesTestCase",
        "kind": 6,
        "importPath": "recursion.test_recursion",
        "description": "recursion.test_recursion",
        "peekOfCode": "class CollectOddValuesTestCase(unittest.TestCase):\n    def test_success(self):\n        self.assertEqual(collect_odd_values([1, 2, 3, 4, 5]), [1, 3, 5])\nclass CollectOddValuesPureTestCase(unittest.TestCase):\n    def test_success(self):\n        self.assertEqual(collect_odd_values_pure([1, 2, 3, 4, 5]), [1, 3, 5])\nclass PowerTestCase(unittest.TestCase):\n    def test_power_of_zero(self):\n        self.assertEqual(power(2, 0), 1)\n    def test_success(self):",
        "detail": "recursion.test_recursion",
        "documentation": {}
    },
    {
        "label": "CollectOddValuesPureTestCase",
        "kind": 6,
        "importPath": "recursion.test_recursion",
        "description": "recursion.test_recursion",
        "peekOfCode": "class CollectOddValuesPureTestCase(unittest.TestCase):\n    def test_success(self):\n        self.assertEqual(collect_odd_values_pure([1, 2, 3, 4, 5]), [1, 3, 5])\nclass PowerTestCase(unittest.TestCase):\n    def test_power_of_zero(self):\n        self.assertEqual(power(2, 0), 1)\n    def test_success(self):\n        self.assertEqual(power(2, 2), 4)\n        self.assertEqual(power(4, 4), 256)\nclass Factorial(unittest.TestCase):",
        "detail": "recursion.test_recursion",
        "documentation": {}
    },
    {
        "label": "PowerTestCase",
        "kind": 6,
        "importPath": "recursion.test_recursion",
        "description": "recursion.test_recursion",
        "peekOfCode": "class PowerTestCase(unittest.TestCase):\n    def test_power_of_zero(self):\n        self.assertEqual(power(2, 0), 1)\n    def test_success(self):\n        self.assertEqual(power(2, 2), 4)\n        self.assertEqual(power(4, 4), 256)\nclass Factorial(unittest.TestCase):\n    def test_success(self):\n        self.assertEqual(factorial(1), 1)\n        self.assertEqual(factorial(2), 2)",
        "detail": "recursion.test_recursion",
        "documentation": {}
    },
    {
        "label": "Factorial",
        "kind": 6,
        "importPath": "recursion.test_recursion",
        "description": "recursion.test_recursion",
        "peekOfCode": "class Factorial(unittest.TestCase):\n    def test_success(self):\n        self.assertEqual(factorial(1), 1)\n        self.assertEqual(factorial(2), 2)\n        self.assertEqual(factorial(4), 24)\n        self.assertEqual(factorial(7), 5040)\n    def test_zero(self):\n        self.assertEqual(factorial(0), 1)\nclass ProductsOfArrayTestCase(unittest.TestCase):\n    def test_success(self):",
        "detail": "recursion.test_recursion",
        "documentation": {}
    },
    {
        "label": "ProductsOfArrayTestCase",
        "kind": 6,
        "importPath": "recursion.test_recursion",
        "description": "recursion.test_recursion",
        "peekOfCode": "class ProductsOfArrayTestCase(unittest.TestCase):\n    def test_success(self):\n        self.assertEqual(product_of_array([1, 2, 3]), 6)\n        self.assertEqual(product_of_array([1, 2, 3, 10]), 60)\n    def test_empty_array_fail(self):\n        with self.assertRaises(Exception) as e:\n            product_of_array([])\n        self.assertEqual(str(e.exception), \"cannot pass an empty list\")\nclass SumRangeTestCase(unittest.TestCase):\n    def test_success(self):",
        "detail": "recursion.test_recursion",
        "documentation": {}
    },
    {
        "label": "SumRangeTestCase",
        "kind": 6,
        "importPath": "recursion.test_recursion",
        "description": "recursion.test_recursion",
        "peekOfCode": "class SumRangeTestCase(unittest.TestCase):\n    def test_success(self):\n        self.assertEqual(sum_range(6), 21)\n        self.assertEqual(sum_range(10), 55)\nclass FibTestCase(unittest.TestCase):\n    def test_success(self):\n        self.assertEqual(fib(4), 3)\n        self.assertEqual(fib(10), 55)\n        self.assertEqual(fib(28), 317811)\n        self.assertEqual(fib(35), 9227465)",
        "detail": "recursion.test_recursion",
        "documentation": {}
    },
    {
        "label": "FibTestCase",
        "kind": 6,
        "importPath": "recursion.test_recursion",
        "description": "recursion.test_recursion",
        "peekOfCode": "class FibTestCase(unittest.TestCase):\n    def test_success(self):\n        self.assertEqual(fib(4), 3)\n        self.assertEqual(fib(10), 55)\n        self.assertEqual(fib(28), 317811)\n        self.assertEqual(fib(35), 9227465)\nclass ReverseTestCase(unittest.TestCase):\n    def test_success(self):\n        self.assertEqual(reverse(\"abc\"), \"cba\")\nclass IsPalindromeTestCase(unittest.TestCase):",
        "detail": "recursion.test_recursion",
        "documentation": {}
    },
    {
        "label": "ReverseTestCase",
        "kind": 6,
        "importPath": "recursion.test_recursion",
        "description": "recursion.test_recursion",
        "peekOfCode": "class ReverseTestCase(unittest.TestCase):\n    def test_success(self):\n        self.assertEqual(reverse(\"abc\"), \"cba\")\nclass IsPalindromeTestCase(unittest.TestCase):\n    def test_success(self):\n        self.assertTrue(is_palindrome(\"tacocat\"))\n        self.assertTrue(is_palindrome(\"amanaplanacanalpanama\"))\n    def test_fail(self):\n        self.assertFalse(is_palindrome(\"awesome\"))\n        self.assertFalse(is_palindrome(\"foobar\"))",
        "detail": "recursion.test_recursion",
        "documentation": {}
    },
    {
        "label": "IsPalindromeTestCase",
        "kind": 6,
        "importPath": "recursion.test_recursion",
        "description": "recursion.test_recursion",
        "peekOfCode": "class IsPalindromeTestCase(unittest.TestCase):\n    def test_success(self):\n        self.assertTrue(is_palindrome(\"tacocat\"))\n        self.assertTrue(is_palindrome(\"amanaplanacanalpanama\"))\n    def test_fail(self):\n        self.assertFalse(is_palindrome(\"awesome\"))\n        self.assertFalse(is_palindrome(\"foobar\"))\n        self.assertFalse(is_palindrome(\"amanaplanacanalpandemonium\"))\nclass SomeRecursiveTestCase(unittest.TestCase):\n    def setUp(self):",
        "detail": "recursion.test_recursion",
        "documentation": {}
    },
    {
        "label": "SomeRecursiveTestCase",
        "kind": 6,
        "importPath": "recursion.test_recursion",
        "description": "recursion.test_recursion",
        "peekOfCode": "class SomeRecursiveTestCase(unittest.TestCase):\n    def setUp(self):\n        self.is_odd: Callable[[int], bool] = lambda num: num % 2 != 0\n    def test_success(self):\n        self.assertTrue(some_recursive([1, 2, 3, 4], self.is_odd))\n        self.assertTrue(some_recursive([4, 6, 9], self.is_odd))\n    def test_fail(self):\n        self.assertFalse(some_recursive([4, 6, 8], self.is_odd))\n        self.assertFalse(some_recursive([4, 6, 8], lambda val: val > 10))\nclass FlattenHelperTestCase(unittest.TestCase):",
        "detail": "recursion.test_recursion",
        "documentation": {}
    },
    {
        "label": "FlattenHelperTestCase",
        "kind": 6,
        "importPath": "recursion.test_recursion",
        "description": "recursion.test_recursion",
        "peekOfCode": "class FlattenHelperTestCase(unittest.TestCase):\n    def test_success(self):\n        self.assertEqual(flatten_helper([1, 2, 3, [4, 5]]), [1, 2, 3, 4, 5])\n        self.assertEqual(flatten_helper([1, [2, [3, 4], [[5]]]]), [1, 2, 3, 4, 5])\n        self.assertEqual(flatten_helper([[1], [2], [3]]), [1, 2, 3])\n        self.assertEqual(flatten_helper([[[[1], [[[2]]], [[[[[[[3]]]]]]]]]]), [1, 2, 3])\nclass FlattenPureTestCase(unittest.TestCase):\n    def test_success(self):\n        self.assertEqual(flatten_pure([1, 2, 3, [4, 5]]), [1, 2, 3, 4, 5])\n        self.assertEqual(flatten_pure([1, [2, [3, 4], [[5]]]]), [1, 2, 3, 4, 5])",
        "detail": "recursion.test_recursion",
        "documentation": {}
    },
    {
        "label": "FlattenPureTestCase",
        "kind": 6,
        "importPath": "recursion.test_recursion",
        "description": "recursion.test_recursion",
        "peekOfCode": "class FlattenPureTestCase(unittest.TestCase):\n    def test_success(self):\n        self.assertEqual(flatten_pure([1, 2, 3, [4, 5]]), [1, 2, 3, 4, 5])\n        self.assertEqual(flatten_pure([1, [2, [3, 4], [[5]]]]), [1, 2, 3, 4, 5])\n        self.assertEqual(flatten_pure([[1], [2], [3]]), [1, 2, 3])\n        self.assertEqual(flatten_pure([[[[1], [[[2]]], [[[[[[[3]]]]]]]]]]), [1, 2, 3])\nclass CapitalizeFirstTestCase(unittest.TestCase):\n    def test_success(self):\n        self.assertEqual(\n            capitalize_first([\"car\", \"taco\", \"banana\"]), [\"Car\", \"Taco\", \"Banana\"]",
        "detail": "recursion.test_recursion",
        "documentation": {}
    },
    {
        "label": "CapitalizeFirstTestCase",
        "kind": 6,
        "importPath": "recursion.test_recursion",
        "description": "recursion.test_recursion",
        "peekOfCode": "class CapitalizeFirstTestCase(unittest.TestCase):\n    def test_success(self):\n        self.assertEqual(\n            capitalize_first([\"car\", \"taco\", \"banana\"]), [\"Car\", \"Taco\", \"Banana\"]\n        )\nclass NestedEvenSumTestCase(unittest.TestCase):\n    def test_success(self):\n        dict1 = {\n            \"outer\": 2,\n            \"obj\": {",
        "detail": "recursion.test_recursion",
        "documentation": {}
    },
    {
        "label": "NestedEvenSumTestCase",
        "kind": 6,
        "importPath": "recursion.test_recursion",
        "description": "recursion.test_recursion",
        "peekOfCode": "class NestedEvenSumTestCase(unittest.TestCase):\n    def test_success(self):\n        dict1 = {\n            \"outer\": 2,\n            \"obj\": {\n                \"inner\": 2,\n                \"otherObj\": {\n                    \"superInner\": 2,\n                    \"notANumber\": True,\n                    \"alsoNotANumber\": \"yup\",",
        "detail": "recursion.test_recursion",
        "documentation": {}
    },
    {
        "label": "CapitalizeWordsTestCase",
        "kind": 6,
        "importPath": "recursion.test_recursion",
        "description": "recursion.test_recursion",
        "peekOfCode": "class CapitalizeWordsTestCase(unittest.TestCase):\n    def test_success(self):\n        words = [\"i\", \"am\", \"learning\", \"recursion\"]\n        self.assertEqual(capitalize_words(words), [\"I\", \"AM\", \"LEARNING\", \"RECURSION\"])\nclass StringifyNumbersTestCase(unittest.TestCase):\n    def test_success(self):\n        dict = {\n            \"num\": 1,\n            \"test\": [],\n            \"data\": {",
        "detail": "recursion.test_recursion",
        "documentation": {}
    },
    {
        "label": "StringifyNumbersTestCase",
        "kind": 6,
        "importPath": "recursion.test_recursion",
        "description": "recursion.test_recursion",
        "peekOfCode": "class StringifyNumbersTestCase(unittest.TestCase):\n    def test_success(self):\n        dict = {\n            \"num\": 1,\n            \"test\": [],\n            \"data\": {\n                \"val\": 4,\n                \"info\": {\n                    \"isRight\": True,\n                    \"random\": 66,",
        "detail": "recursion.test_recursion",
        "documentation": {}
    },
    {
        "label": "CollectStringsTestCase",
        "kind": 6,
        "importPath": "recursion.test_recursion",
        "description": "recursion.test_recursion",
        "peekOfCode": "class CollectStringsTestCase(unittest.TestCase):\n    def test_success(self):\n        dict = {\n            \"stuff\": \"foo\",\n            \"data\": {\n                \"val\": {\n                    \"thing\": {\n                        \"info\": \"bar\",\n                        \"moreInfo\": {\n                            \"evenMoreInfo\": {",
        "detail": "recursion.test_recursion",
        "documentation": {}
    },
    {
        "label": "Comparable",
        "kind": 6,
        "importPath": "searching-algorithms.searching_algorithms",
        "description": "searching-algorithms.searching_algorithms",
        "peekOfCode": "class Comparable(metaclass=ABCMeta):\n    @abstractmethod\n    def __lt__(self, other: Any) -> bool:\n        pass\nCT = TypeVar(\"CT\", bound=Comparable)\ndef linear_search(arr: List[Any], target: Any) -> int:\n    for i, item in enumerate(arr):\n        if item == target:\n            return i\n    return -1",
        "detail": "searching-algorithms.searching_algorithms",
        "documentation": {}
    },
    {
        "label": "linear_search",
        "kind": 2,
        "importPath": "searching-algorithms.searching_algorithms",
        "description": "searching-algorithms.searching_algorithms",
        "peekOfCode": "def linear_search(arr: List[Any], target: Any) -> int:\n    for i, item in enumerate(arr):\n        if item == target:\n            return i\n    return -1\ndef binary_search(arr: List[CT], target: CT) -> int:\n    head = 0\n    tail = len(arr) - 1\n    while head <= tail:\n        mid = math.floor(tail - head / 2)",
        "detail": "searching-algorithms.searching_algorithms",
        "documentation": {}
    },
    {
        "label": "binary_search",
        "kind": 2,
        "importPath": "searching-algorithms.searching_algorithms",
        "description": "searching-algorithms.searching_algorithms",
        "peekOfCode": "def binary_search(arr: List[CT], target: CT) -> int:\n    head = 0\n    tail = len(arr) - 1\n    while head <= tail:\n        mid = math.floor(tail - head / 2)\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            head = mid + 1\n        elif target < arr[mid]:",
        "detail": "searching-algorithms.searching_algorithms",
        "documentation": {}
    },
    {
        "label": "naive_string_search",
        "kind": 2,
        "importPath": "searching-algorithms.searching_algorithms",
        "description": "searching-algorithms.searching_algorithms",
        "peekOfCode": "def naive_string_search(source: str, sub_str: str) -> int:\n    count = 0\n    for i, char in enumerate(source):\n        if char == sub_str[0]:\n            match = True\n            for j, sub_char in enumerate(sub_str):\n                if sub_char != source[i + j]:\n                    match = False\n            if match:\n                count += 1",
        "detail": "searching-algorithms.searching_algorithms",
        "documentation": {}
    },
    {
        "label": "CT",
        "kind": 5,
        "importPath": "searching-algorithms.searching_algorithms",
        "description": "searching-algorithms.searching_algorithms",
        "peekOfCode": "CT = TypeVar(\"CT\", bound=Comparable)\ndef linear_search(arr: List[Any], target: Any) -> int:\n    for i, item in enumerate(arr):\n        if item == target:\n            return i\n    return -1\ndef binary_search(arr: List[CT], target: CT) -> int:\n    head = 0\n    tail = len(arr) - 1\n    while head <= tail:",
        "detail": "searching-algorithms.searching_algorithms",
        "documentation": {}
    },
    {
        "label": "LinearSearchTestCase",
        "kind": 6,
        "importPath": "searching-algorithms.test_searching_algorithms",
        "description": "searching-algorithms.test_searching_algorithms",
        "peekOfCode": "class LinearSearchTestCase(unittest.TestCase):\n    def test_success(self):\n        self.assertEqual(linear_search([3, 1, 2], 1), 1)\n    def test_not_found(self):\n        self.assertEqual(linear_search([3, 1, 2], 4), -1)\nclass BinarySearchTestCase(unittest.TestCase):\n    def test_success(self):\n        self.assertEqual(binary_search([1, 2, 3, 4], 4), 3)\n        self.assertEqual(binary_search([1, 2, 3, 4, 5, 6, 7], 1), 0)\n        self.assertEqual(binary_search([1, 2, 3, 4, 5, 6, 7], 7), 6)",
        "detail": "searching-algorithms.test_searching_algorithms",
        "documentation": {}
    },
    {
        "label": "BinarySearchTestCase",
        "kind": 6,
        "importPath": "searching-algorithms.test_searching_algorithms",
        "description": "searching-algorithms.test_searching_algorithms",
        "peekOfCode": "class BinarySearchTestCase(unittest.TestCase):\n    def test_success(self):\n        self.assertEqual(binary_search([1, 2, 3, 4], 4), 3)\n        self.assertEqual(binary_search([1, 2, 3, 4, 5, 6, 7], 1), 0)\n        self.assertEqual(binary_search([1, 2, 3, 4, 5, 6, 7], 7), 6)\n        self.assertEqual(binary_search([1, 2, 3, 4, 5, 6, 7], 4), 3)\n        self.assertEqual(binary_search([1, 2, 3, 4, 5, 6], 3), 2)\n    def test_not_found(self):\n        self.assertEqual(binary_search([1, 2, 3], 4), -1)\nclass NaiveStringSearch(unittest.TestCase):",
        "detail": "searching-algorithms.test_searching_algorithms",
        "documentation": {}
    },
    {
        "label": "NaiveStringSearch",
        "kind": 6,
        "importPath": "searching-algorithms.test_searching_algorithms",
        "description": "searching-algorithms.test_searching_algorithms",
        "peekOfCode": "class NaiveStringSearch(unittest.TestCase):\n    def test_success(self):\n        self.assertEqual(\n            naive_string_search(\"This is very slow naive string search\", \"is\"), 2\n        )",
        "detail": "searching-algorithms.test_searching_algorithms",
        "documentation": {}
    },
    {
        "label": "Comparable",
        "kind": 6,
        "importPath": "sorting-algorithms.sorting_algorithms",
        "description": "sorting-algorithms.sorting_algorithms",
        "peekOfCode": "class Comparable(metaclass=ABCMeta):\n    @abstractmethod\n    def __lt__(self, other: Any) -> bool:\n        pass\nCT = TypeVar(\"CT\", bound=Comparable)\ndef swap(arr: List[Any], index1: int, index2: int):\n    temp = arr[index1]\n    arr[index1] = arr[index2]\n    arr[index2] = temp\ndef get_max_entry(arr: List[CT]):",
        "detail": "sorting-algorithms.sorting_algorithms",
        "documentation": {}
    },
    {
        "label": "swap",
        "kind": 2,
        "importPath": "sorting-algorithms.sorting_algorithms",
        "description": "sorting-algorithms.sorting_algorithms",
        "peekOfCode": "def swap(arr: List[Any], index1: int, index2: int):\n    temp = arr[index1]\n    arr[index1] = arr[index2]\n    arr[index2] = temp\ndef get_max_entry(arr: List[CT]):\n    current_max_index = 0\n    current_max = arr[current_max_index]\n    for index, value in enumerate(arr):\n        if value > current_max:\n            current_max_index = index",
        "detail": "sorting-algorithms.sorting_algorithms",
        "documentation": {}
    },
    {
        "label": "get_max_entry",
        "kind": 2,
        "importPath": "sorting-algorithms.sorting_algorithms",
        "description": "sorting-algorithms.sorting_algorithms",
        "peekOfCode": "def get_max_entry(arr: List[CT]):\n    current_max_index = 0\n    current_max = arr[current_max_index]\n    for index, value in enumerate(arr):\n        if value > current_max:\n            current_max_index = index\n            current_max = arr[current_max_index]\n    return (current_max_index, current_max)\ndef bubble_sort_while(arr: List[CT]) -> List[CT]:\n    result = arr.copy()",
        "detail": "sorting-algorithms.sorting_algorithms",
        "documentation": {}
    },
    {
        "label": "bubble_sort_while",
        "kind": 2,
        "importPath": "sorting-algorithms.sorting_algorithms",
        "description": "sorting-algorithms.sorting_algorithms",
        "peekOfCode": "def bubble_sort_while(arr: List[CT]) -> List[CT]:\n    result = arr.copy()\n    tail_index = len(arr) - 1\n    while tail_index > 0:\n        (max_index, _) = get_max_entry(result[0 : tail_index + 1])\n        swap(result, max_index, tail_index)\n        tail_index -= 1\n    return result\ndef bubble_sort(arr: List[CT]) -> List[CT]:\n    copied_arr = arr.copy()",
        "detail": "sorting-algorithms.sorting_algorithms",
        "documentation": {}
    },
    {
        "label": "bubble_sort",
        "kind": 2,
        "importPath": "sorting-algorithms.sorting_algorithms",
        "description": "sorting-algorithms.sorting_algorithms",
        "peekOfCode": "def bubble_sort(arr: List[CT]) -> List[CT]:\n    copied_arr = arr.copy()\n    for i in range(len(copied_arr) - 1, 0, -1):\n        has_been_swapped = False\n        # i is the index of the last element in the subarray\n        for j in range(i):\n            if copied_arr[j] > copied_arr[j + 1]:\n                swap(copied_arr, j, j + 1)\n                has_been_swapped = True\n        # optimization: it's been already sorted, so didn't have to swap while looping through the entire subarray",
        "detail": "sorting-algorithms.sorting_algorithms",
        "documentation": {}
    },
    {
        "label": "get_min_entry",
        "kind": 2,
        "importPath": "sorting-algorithms.sorting_algorithms",
        "description": "sorting-algorithms.sorting_algorithms",
        "peekOfCode": "def get_min_entry(arr: List[CT]) -> int:\n    min = arr[0]\n    min_index = 0\n    for i, val in enumerate(arr):\n        if val < min:\n            min = val\n            min_index = i\n    return min_index, min\ndef selection_sort(arr: List[CT]) -> List[CT]:\n    copied_arr = arr.copy()",
        "detail": "sorting-algorithms.sorting_algorithms",
        "documentation": {}
    },
    {
        "label": "selection_sort",
        "kind": 2,
        "importPath": "sorting-algorithms.sorting_algorithms",
        "description": "sorting-algorithms.sorting_algorithms",
        "peekOfCode": "def selection_sort(arr: List[CT]) -> List[CT]:\n    copied_arr = arr.copy()\n    for i in range(len(arr)):\n        min_index_of_subarray, _ = get_min_entry(copied_arr[i:])\n        min_index = min_index_of_subarray + i\n        swap(copied_arr, min_index, i)\n    return copied_arr\ndef insertion_sort_swap(arr: List[CT]) -> List[CT]:\n    # if there is less than two items, it's already sorted\n    if len(arr) < 2:",
        "detail": "sorting-algorithms.sorting_algorithms",
        "documentation": {}
    },
    {
        "label": "insertion_sort_swap",
        "kind": 2,
        "importPath": "sorting-algorithms.sorting_algorithms",
        "description": "sorting-algorithms.sorting_algorithms",
        "peekOfCode": "def insertion_sort_swap(arr: List[CT]) -> List[CT]:\n    # if there is less than two items, it's already sorted\n    if len(arr) < 2:\n        return arr\n    arr_copy = arr.copy()\n    # the subarray should start from the array of one item because\n    # it might be greater than the second item (inserting item)\n    subarr_tail = 0\n    # grow subarr each time until it becomes n - 1\n    # because we're going to insert the item at n",
        "detail": "sorting-algorithms.sorting_algorithms",
        "documentation": {}
    },
    {
        "label": "insertion_sort",
        "kind": 2,
        "importPath": "sorting-algorithms.sorting_algorithms",
        "description": "sorting-algorithms.sorting_algorithms",
        "peekOfCode": "def insertion_sort(arr: List[CT]) -> List[CT]:\n    if len(arr) < 2:\n        # already sorted. return.\n        return arr\n    arr_copy = arr.copy()\n    for inserting_item_index in range(1, len(arr)):\n        inserting_item = arr_copy[inserting_item_index]\n        # loop from the last item in the subarray back to the first item\n        for curr_subarr_item_index in range(inserting_item_index - 1, -1, -1):\n            curr_subarr_item = arr_copy[curr_subarr_item_index]",
        "detail": "sorting-algorithms.sorting_algorithms",
        "documentation": {}
    },
    {
        "label": "compare_and_sort",
        "kind": 2,
        "importPath": "sorting-algorithms.sorting_algorithms",
        "description": "sorting-algorithms.sorting_algorithms",
        "peekOfCode": "def compare_and_sort(sorted_arr1: List[CT], sorted_arr2: List[CT]) -> List[CT]:\n    result = []\n    i = 0\n    j = 0\n    while i < len(sorted_arr1) and j < len(sorted_arr2):\n        if sorted_arr1[i] < sorted_arr2[j]:\n            result.append(sorted_arr1[i])\n            i += 1\n        else:\n            result.append(sorted_arr2[j])",
        "detail": "sorting-algorithms.sorting_algorithms",
        "documentation": {}
    },
    {
        "label": "merge_sort",
        "kind": 2,
        "importPath": "sorting-algorithms.sorting_algorithms",
        "description": "sorting-algorithms.sorting_algorithms",
        "peekOfCode": "def merge_sort(arr: List[CT]) -> List[CT]:\n    if len(arr) < 2:\n        return arr\n    mid = floor(len(arr) / 2)\n    left = arr[0:mid]\n    right = arr[mid:]\n    # keep breaking the arr in half until there is a single item\n    # backtrack to merge them into a single array.\n    return compare_and_sort(merge_sort(left), merge_sort(right))\n\"\"\"",
        "detail": "sorting-algorithms.sorting_algorithms",
        "documentation": {}
    },
    {
        "label": "pivot",
        "kind": 2,
        "importPath": "sorting-algorithms.sorting_algorithms",
        "description": "sorting-algorithms.sorting_algorithms",
        "peekOfCode": "def pivot(arr: List[CT], head_index: int = 0, tail_index: int = None) -> int:\n    if tail_index is None:\n        tail_index = len(arr) - 1\n    pivot_index = head_index\n    curr_index = pivot_index + 1\n    while curr_index <= tail_index:\n        if arr[curr_index] < arr[head_index]:\n            swap(arr, curr_index, pivot_index + 1)\n            # found smaller value, move index that pivot needs to move to\n            pivot_index += 1",
        "detail": "sorting-algorithms.sorting_algorithms",
        "documentation": {}
    },
    {
        "label": "quick_sort",
        "kind": 2,
        "importPath": "sorting-algorithms.sorting_algorithms",
        "description": "sorting-algorithms.sorting_algorithms",
        "peekOfCode": "def quick_sort(arr: List[CT], head_index: int = 0, tail_index: int = None) -> List[CT]:\n    # set default tail_index\n    if tail_index is None:\n        tail_index = len(arr) - 1\n    # base case - less than or equal to 1 array item (tail is the last item)\n    if tail_index - head_index < 1:\n        return arr\n    pivot_index = pivot(arr, head_index, tail_index)\n    quick_sort(arr, head_index, pivot_index - 1)\n    quick_sort(arr, pivot_index + 1, tail_index)",
        "detail": "sorting-algorithms.sorting_algorithms",
        "documentation": {}
    },
    {
        "label": "flatten",
        "kind": 2,
        "importPath": "sorting-algorithms.sorting_algorithms",
        "description": "sorting-algorithms.sorting_algorithms",
        "peekOfCode": "def flatten(array):\n    flattened = []\n    for subarray in array:\n        for item in subarray:\n            flattened.append(item)\n    return flattened\ndef get_num_digits(val):\n    num_digit = 0\n    while val > 0:\n        num_digit += 1",
        "detail": "sorting-algorithms.sorting_algorithms",
        "documentation": {}
    },
    {
        "label": "get_num_digits",
        "kind": 2,
        "importPath": "sorting-algorithms.sorting_algorithms",
        "description": "sorting-algorithms.sorting_algorithms",
        "peekOfCode": "def get_num_digits(val):\n    num_digit = 0\n    while val > 0:\n        num_digit += 1\n        val = floor(val / 10)\n    return num_digit\ndef get_max_digits(arr):\n    \"\"\"Find the maximum number of digits of any item\"\"\"\n    digits = [get_num_digits(val) for val in arr]\n    return max(digits)",
        "detail": "sorting-algorithms.sorting_algorithms",
        "documentation": {}
    },
    {
        "label": "get_max_digits",
        "kind": 2,
        "importPath": "sorting-algorithms.sorting_algorithms",
        "description": "sorting-algorithms.sorting_algorithms",
        "peekOfCode": "def get_max_digits(arr):\n    \"\"\"Find the maximum number of digits of any item\"\"\"\n    digits = [get_num_digits(val) for val in arr]\n    return max(digits)\ndef get_ith_digit(val, i):\n    return floor(val / 10 ** i) % 10\ndef radix_sort(arr: List[CT]) -> List[CT]:\n    # loop from the right-most digit to the highest digit\n    for i in range(get_max_digits(arr)):\n        # initialize buckets for base 10 numbers",
        "detail": "sorting-algorithms.sorting_algorithms",
        "documentation": {}
    },
    {
        "label": "get_ith_digit",
        "kind": 2,
        "importPath": "sorting-algorithms.sorting_algorithms",
        "description": "sorting-algorithms.sorting_algorithms",
        "peekOfCode": "def get_ith_digit(val, i):\n    return floor(val / 10 ** i) % 10\ndef radix_sort(arr: List[CT]) -> List[CT]:\n    # loop from the right-most digit to the highest digit\n    for i in range(get_max_digits(arr)):\n        # initialize buckets for base 10 numbers\n        buckets = [[] for _ in range(10)]\n        # for each place, we're sorting by the digit value\n        # as we go up in places, all the values less than the current place are already sorted among themselves\n        for val in arr:",
        "detail": "sorting-algorithms.sorting_algorithms",
        "documentation": {}
    },
    {
        "label": "radix_sort",
        "kind": 2,
        "importPath": "sorting-algorithms.sorting_algorithms",
        "description": "sorting-algorithms.sorting_algorithms",
        "peekOfCode": "def radix_sort(arr: List[CT]) -> List[CT]:\n    # loop from the right-most digit to the highest digit\n    for i in range(get_max_digits(arr)):\n        # initialize buckets for base 10 numbers\n        buckets = [[] for _ in range(10)]\n        # for each place, we're sorting by the digit value\n        # as we go up in places, all the values less than the current place are already sorted among themselves\n        for val in arr:\n            ith_digit = get_ith_digit(val, i)\n            buckets[ith_digit].append(val)",
        "detail": "sorting-algorithms.sorting_algorithms",
        "documentation": {}
    },
    {
        "label": "CT",
        "kind": 5,
        "importPath": "sorting-algorithms.sorting_algorithms",
        "description": "sorting-algorithms.sorting_algorithms",
        "peekOfCode": "CT = TypeVar(\"CT\", bound=Comparable)\ndef swap(arr: List[Any], index1: int, index2: int):\n    temp = arr[index1]\n    arr[index1] = arr[index2]\n    arr[index2] = temp\ndef get_max_entry(arr: List[CT]):\n    current_max_index = 0\n    current_max = arr[current_max_index]\n    for index, value in enumerate(arr):\n        if value > current_max:",
        "detail": "sorting-algorithms.sorting_algorithms",
        "documentation": {}
    },
    {
        "label": "BubbleSortTestCase",
        "kind": 6,
        "importPath": "sorting-algorithms.test_sorting_algorithms",
        "description": "sorting-algorithms.test_sorting_algorithms",
        "peekOfCode": "class BubbleSortTestCase(unittest.TestCase):\n    def test_success(self):\n        self.assertEqual(bubble_sort([5, 2, 8, -3, 0, -65]), [-65, -3, 0, 2, 5, 8])\n    def test_faster_with_almost_sorted_array(self):\n        sorted_numbers = [i for i in range(1000)]\n        reverse_sorted_numbers = sorted_numbers.copy()\n        reverse_sorted_numbers.reverse()\n        sorted_delta, sorted_result = time_func(lambda: bubble_sort(sorted_numbers))\n        reverse_delta, reverse_result = time_func(\n            lambda: bubble_sort(reverse_sorted_numbers)",
        "detail": "sorting-algorithms.test_sorting_algorithms",
        "documentation": {}
    },
    {
        "label": "SelectionSortTestCase",
        "kind": 6,
        "importPath": "sorting-algorithms.test_sorting_algorithms",
        "description": "sorting-algorithms.test_sorting_algorithms",
        "peekOfCode": "class SelectionSortTestCase(unittest.TestCase):\n    def test_success(self):\n        self.assertEqual(selection_sort([5, 2, 8, -3, 0, -65]), [-65, -3, 0, 2, 5, 8])\nclass InsertionSortTestCase(unittest.TestCase):\n    def test_success(self):\n        self.assertEqual(insertion_sort([5, 2, 8, -3, 0, -65]), [-65, -3, 0, 2, 5, 8])\n    def test_appending_item(self):\n        reverse_sorted_numbers = [1000 - i for i in range(1000)]\n        delta, result = time_func(lambda: insertion_sort(reverse_sorted_numbers))\n        new_array = [*result, -100]",
        "detail": "sorting-algorithms.test_sorting_algorithms",
        "documentation": {}
    },
    {
        "label": "InsertionSortTestCase",
        "kind": 6,
        "importPath": "sorting-algorithms.test_sorting_algorithms",
        "description": "sorting-algorithms.test_sorting_algorithms",
        "peekOfCode": "class InsertionSortTestCase(unittest.TestCase):\n    def test_success(self):\n        self.assertEqual(insertion_sort([5, 2, 8, -3, 0, -65]), [-65, -3, 0, 2, 5, 8])\n    def test_appending_item(self):\n        reverse_sorted_numbers = [1000 - i for i in range(1000)]\n        delta, result = time_func(lambda: insertion_sort(reverse_sorted_numbers))\n        new_array = [*result, -100]\n        new_delta, new_result = time_func(lambda: insertion_sort(new_array))\n        self.assertLess(new_delta, delta / 2)\n        self.assertEqual(new_result, [-100, *result])",
        "detail": "sorting-algorithms.test_sorting_algorithms",
        "documentation": {}
    },
    {
        "label": "CompareAndSortTestCase",
        "kind": 6,
        "importPath": "sorting-algorithms.test_sorting_algorithms",
        "description": "sorting-algorithms.test_sorting_algorithms",
        "peekOfCode": "class CompareAndSortTestCase(unittest.TestCase):\n    def test_success(self):\n        self.assertEqual(\n            compare_and_sort([1, 4, 7], [2, 3, 8, 12]), [1, 2, 3, 4, 7, 8, 12]\n        )\n        self.assertEqual(\n            compare_and_sort([1, 2, 5], [-65, -3, 0, 8]), [-65, -3, 0, 1, 2, 5, 8]\n        )\n    def test_one_empty_array(self):\n        self.assertEqual(compare_and_sort([], [2, 3, 8, 12]), [2, 3, 8, 12])",
        "detail": "sorting-algorithms.test_sorting_algorithms",
        "documentation": {}
    },
    {
        "label": "MergeSortTestCase",
        "kind": 6,
        "importPath": "sorting-algorithms.test_sorting_algorithms",
        "description": "sorting-algorithms.test_sorting_algorithms",
        "peekOfCode": "class MergeSortTestCase(unittest.TestCase):\n    def test_success(self):\n        self.assertEqual(merge_sort([1, 5, 2, 8, -3, 0, -65]), [-65, -3, 0, 1, 2, 5, 8])\nclass PivotTestCase(unittest.TestCase):\n    def test_returns_pivot_index(self):\n        self.assertEqual(pivot([5, 2, 4, 1, 13, 8]), 3)\n    def test_reorganizes_items(self):\n        arr = [3, 2, 1]\n        pivot(arr)\n        self.assertEqual(arr, [1, 2, 3])",
        "detail": "sorting-algorithms.test_sorting_algorithms",
        "documentation": {}
    },
    {
        "label": "PivotTestCase",
        "kind": 6,
        "importPath": "sorting-algorithms.test_sorting_algorithms",
        "description": "sorting-algorithms.test_sorting_algorithms",
        "peekOfCode": "class PivotTestCase(unittest.TestCase):\n    def test_returns_pivot_index(self):\n        self.assertEqual(pivot([5, 2, 4, 1, 13, 8]), 3)\n    def test_reorganizes_items(self):\n        arr = [3, 2, 1]\n        pivot(arr)\n        self.assertEqual(arr, [1, 2, 3])\n    def test_smaller_values_to_the_left(self):\n        arr = [5, 2, 13, 1, 4, 8]\n        pivot_index = pivot(arr)",
        "detail": "sorting-algorithms.test_sorting_algorithms",
        "documentation": {}
    },
    {
        "label": "QuickSortTestCase",
        "kind": 6,
        "importPath": "sorting-algorithms.test_sorting_algorithms",
        "description": "sorting-algorithms.test_sorting_algorithms",
        "peekOfCode": "class QuickSortTestCase(unittest.TestCase):\n    def test_success(self):\n        arr = [5, 2, 4, 1, 13, 8]\n        quick_sort(arr)\n        self.assertEqual(arr, [1, 2, 4, 5, 8, 13])\n    def test_repeated_values(self):\n        arr = [1, 2, 3, 1, 2, 3, 1, 2, 3]\n        quick_sort(arr)\n        self.assertEqual(arr, [1, 1, 1, 2, 2, 2, 3, 3, 3])\n    def test_single_value(self):",
        "detail": "sorting-algorithms.test_sorting_algorithms",
        "documentation": {}
    },
    {
        "label": "RadixSortTestCase",
        "kind": 6,
        "importPath": "sorting-algorithms.test_sorting_algorithms",
        "description": "sorting-algorithms.test_sorting_algorithms",
        "peekOfCode": "class RadixSortTestCase(unittest.TestCase):\n    def test_flatten(self):\n        self.assertEqual(flatten([[1], [2], [3]]), [1, 2, 3])\n    def test_get_num_digits(self):\n        self.assertEqual(get_num_digits(123456), 6)\n    def test_max_digits(self):\n        self.assertEqual(get_max_digits([1, 11, 111]), 3)\n    def test_get_ith_digit(self):\n        self.assertEqual(get_ith_digit(123456, 2), 4)\n    def test_success(self):",
        "detail": "sorting-algorithms.test_sorting_algorithms",
        "documentation": {}
    },
    {
        "label": "parse_list",
        "kind": 2,
        "importPath": "utils.parser",
        "description": "utils.parser",
        "peekOfCode": "def parse_list(test_case_path: str, separator=\" \", to_int=False):\n    # read mode (\"r\") is by default\n    with open(test_case_path, \"r\") as file:\n        list_string = file.read().strip()\n        parsed_list = list_string.split(separator)\n    if to_int:\n        parsed_list = list(map(int, parsed_list))\n    return parsed_list",
        "detail": "utils.parser",
        "documentation": {}
    },
    {
        "label": "time_func",
        "kind": 2,
        "importPath": "utils.time",
        "description": "utils.time",
        "peekOfCode": "def time_func(cb: Callable[[], Any]):\n    start_time = time()\n    return_value = cb()\n    finish_time = time()\n    delta = finish_time - start_time\n    return (delta, return_value)",
        "detail": "utils.time",
        "documentation": {}
    },
    {
        "label": "target_bits",
        "kind": 5,
        "importPath": "various-scripts.years_to_reach_41_bits",
        "description": "various-scripts.years_to_reach_41_bits",
        "peekOfCode": "target_bits = 41\n# Current number of bits\ncurrent_bits = 0\n# Number of milliseconds in 1 year\nmilliseconds_in_year = 365 * 24 * 60 * 60 * 1000\n# Counter for years\nyears = 1\n# Iterate until the required number of bits is reached\nwhile current_bits < target_bits:\n    # int(2) = bin(10) = 2 bits. log2(2) = 1",
        "detail": "various-scripts.years_to_reach_41_bits",
        "documentation": {}
    },
    {
        "label": "current_bits",
        "kind": 5,
        "importPath": "various-scripts.years_to_reach_41_bits",
        "description": "various-scripts.years_to_reach_41_bits",
        "peekOfCode": "current_bits = 0\n# Number of milliseconds in 1 year\nmilliseconds_in_year = 365 * 24 * 60 * 60 * 1000\n# Counter for years\nyears = 1\n# Iterate until the required number of bits is reached\nwhile current_bits < target_bits:\n    # int(2) = bin(10) = 2 bits. log2(2) = 1\n    # int(3) = bin(11) = 2 bits. log2(3) = 1.584962500721156\n    # int(4) = bin(100) = 3 bits. log2(4) = 2",
        "detail": "various-scripts.years_to_reach_41_bits",
        "documentation": {}
    },
    {
        "label": "milliseconds_in_year",
        "kind": 5,
        "importPath": "various-scripts.years_to_reach_41_bits",
        "description": "various-scripts.years_to_reach_41_bits",
        "peekOfCode": "milliseconds_in_year = 365 * 24 * 60 * 60 * 1000\n# Counter for years\nyears = 1\n# Iterate until the required number of bits is reached\nwhile current_bits < target_bits:\n    # int(2) = bin(10) = 2 bits. log2(2) = 1\n    # int(3) = bin(11) = 2 bits. log2(3) = 1.584962500721156\n    # int(4) = bin(100) = 3 bits. log2(4) = 2\n    current_bits = (\n        math.floor(math.log2(milliseconds_in_year * years)) + 1 if years > 0 else 0",
        "detail": "various-scripts.years_to_reach_41_bits",
        "documentation": {}
    },
    {
        "label": "years",
        "kind": 5,
        "importPath": "various-scripts.years_to_reach_41_bits",
        "description": "various-scripts.years_to_reach_41_bits",
        "peekOfCode": "years = 1\n# Iterate until the required number of bits is reached\nwhile current_bits < target_bits:\n    # int(2) = bin(10) = 2 bits. log2(2) = 1\n    # int(3) = bin(11) = 2 bits. log2(3) = 1.584962500721156\n    # int(4) = bin(100) = 3 bits. log2(4) = 2\n    current_bits = (\n        math.floor(math.log2(milliseconds_in_year * years)) + 1 if years > 0 else 0\n    )\n    years += 1",
        "detail": "various-scripts.years_to_reach_41_bits",
        "documentation": {}
    },
    {
        "label": "foo",
        "kind": 2,
        "importPath": "scratch",
        "description": "scratch",
        "peekOfCode": "def foo(name):\n    name = \"Jane\"\n    print(name)\nfoo(name)\nprint(name)",
        "detail": "scratch",
        "documentation": {}
    },
    {
        "label": "name",
        "kind": 5,
        "importPath": "scratch",
        "description": "scratch",
        "peekOfCode": "name = \"John\"\ndef foo(name):\n    name = \"Jane\"\n    print(name)\nfoo(name)\nprint(name)",
        "detail": "scratch",
        "documentation": {}
    }
]